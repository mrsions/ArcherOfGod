# Senior Unity Developer Technical Interview Questions

General technical questions commonly asked in game company interviews for senior Unity developers.

---

## Section 1: Unity Engine Deep Dive

Q.1. Unity의 생명주기(Lifecycle) 함수 호출 순서를 설명해주세요. Awake, OnEnable, Start의 차이는?
짧은답: Awake(인스턴스화)→OnEnable(활성화)→Start(첫 프레임 전) 순서이며, Awake는 비활성 오브젝트도 호출됩니다.
긴답: Awake는 스크립트 인스턴스가 로드될 때 호출되며 비활성 GameObject도 실행됩니다. OnEnable은 오브젝트가 활성화될 때마다 호출되고, Start는 첫 Update 직전에 한 번만 호출됩니다. 풀링에서는 OnEnable을 초기화에 활용하고, Awake는 참조 캐싱에 사용합니다.
키워드: 인스턴스화 → 활성화 → 첫프레임

Q.2. Update, FixedUpdate, LateUpdate의 차이와 각각 어떤 로직에 사용하나요?
짧은답: Update(프레임), FixedUpdate(물리), LateUpdate(카메라/후처리)로 구분해 사용합니다.
긴답: Update는 매 프레임 호출되어 입력/상태 판단에 적합합니다. FixedUpdate는 고정 시간 간격(기본 0.02초)으로 물리 연산에 사용합니다. LateUpdate는 모든 Update 이후 호출되어 카메라 따라가기나 애니메이션 후처리에 씁니다. 물리 이동을 Update에서 하면 프레임 의존적이 되어 떨림이 발생합니다.
키워드: 프레임의존 → 물리고정 → 후처리

Q.3. Coroutine과 Async/Await(UniTask)의 차이점과 각각 언제 사용하나요?
짧은답: Coroutine은 Unity 프레임 기반, UniTask는 진정한 비동기로 취소/예외 처리가 우수합니다.
긴답: Coroutine은 Unity 메인 스레드에서 프레임 단위로 실행되며 IEnumerator 기반입니다. UniTask는 async/await 패턴으로 진정한 비동기 처리가 가능하고, CancellationToken으로 취소가 명확하며, 예외 처리도 try-catch로 자연스럽습니다. 단순 딜레이는 Coroutine, 복잡한 비동기 흐름이나 네트워크는 UniTask가 적합합니다.
키워드: 프레임기반 → 진정한비동기 → 취소/예외

Q.4. Unity의 ScriptableObject는 무엇이고 어떤 상황에서 사용하나요?
짧은답: 코드와 분리된 데이터 컨테이너로, 게임 설정/스킬/아이템 데이터 관리에 사용합니다.
긴답: ScriptableObject는 MonoBehaviour와 달리 씬에 종속되지 않는 데이터 에셋입니다. 런타임에 인스턴스가 공유되어 메모리 효율적이고, 기획자가 코드 수정 없이 데이터를 조정할 수 있습니다. 스킬 정의, 아이템 DB, 게임 설정, 이벤트 채널 등에 활용합니다. 단, 런타임 수정 시 원본이 바뀌므로 Instantiate로 복사해서 써야 합니다.
키워드: 데이터분리 → 메모리공유 → 기획친화

Q.5. Addressables와 AssetBundle의 차이점은 무엇인가요?
짧은답: Addressables는 AssetBundle을 추상화한 상위 시스템으로, 참조 카운팅과 종속성 관리를 자동화합니다.
긴답: AssetBundle은 저수준 API로 직접 로드/언로드와 종속성을 관리해야 합니다. Addressables는 이를 추상화하여 주소(키) 기반 로드, 자동 참조 카운팅, 종속성 해결, 로컬/원격 전환을 제공합니다. 신규 프로젝트는 Addressables 권장이며, 레거시 프로젝트에서 AssetBundle 직접 제어가 필요할 때만 AssetBundle을 씁니다.
키워드: 저수준 → 추상화 → 참조카운팅

Q.6. Unity의 렌더링 파이프라인(Built-in, URP, HDRP)의 차이와 선택 기준은?
짧은답: Built-in(레거시), URP(모바일/성능), HDRP(고사양/콘솔/PC)로 플랫폼과 품질 요구에 따라 선택합니다.
긴답: Built-in RP는 레거시로 커스터마이징이 제한적입니다. URP는 모바일/중저사양 PC에 최적화되어 배칭과 SRP Batcher로 드로우콜을 줄입니다. HDRP는 고품질 라이팅/GI/레이트레이싱을 지원하며 콘솔/고사양 PC용입니다. 프로젝트 시작 시 타겟 플랫폼에 맞춰 선택해야 하며, 중간 전환은 비용이 큽니다.
키워드: 레거시 → 성능최적화 → 고품질

Q.7. Draw Call과 Batching의 개념을 설명하고, 최적화 방법은?
짧은답: Draw Call은 GPU 렌더 명령이고, Static/Dynamic Batching, SRP Batcher, GPU Instancing으로 줄입니다.
긴답: Draw Call은 CPU가 GPU에 렌더링을 요청하는 단위로, 많아지면 CPU 병목이 됩니다. Static Batching은 움직이지 않는 오브젝트를 합치고, Dynamic Batching은 작은 메시를 런타임에 합칩니다. SRP Batcher는 머티리얼 변경 비용을 줄이고, GPU Instancing은 동일 메시를 한 번에 그립니다. 아틀라스로 텍스처를 합치는 것도 효과적입니다.
키워드: CPU병목 → 배칭 → 인스턴싱

Q.8. Unity에서 메모리 누수가 발생하는 주요 원인과 디버깅 방법은?
짧은답: 이벤트 미해제, 정적 참조, 순환 참조가 주요 원인이며, Memory Profiler로 스냅샷 비교합니다.
긴답: 주요 원인은 이벤트/델리게이트 구독 해제 누락, static 변수의 참조 유지, 클로저의 의도치 않은 캡처입니다. Unity Memory Profiler로 힙 스냅샷을 찍어 비교하면 증가하는 객체를 찾을 수 있습니다. Profiler에서 GC.Alloc을 추적하고, 풀링되지 않은 반복 생성을 찾아 수정합니다.
키워드: 이벤트누수 → 정적참조 → 스냅샷비교

Q.9. Unity의 Physics.Raycast와 Physics.RaycastNonAlloc의 차이는?
짧은답: Raycast는 매번 배열을 할당하고, NonAlloc은 미리 할당된 버퍼를 재사용해 GC를 줄입니다.
긴답: Physics.RaycastAll은 호출마다 RaycastHit[] 배열을 새로 할당해 GC 부하가 생깁니다. RaycastNonAlloc은 미리 할당한 배열을 전달받아 재사용하므로 할당이 없습니다. 전투나 센서처럼 매 프레임 레이캐스트가 필요한 경우 NonAlloc 버전을 쓰는 게 필수입니다.
키워드: 매번할당 → 버퍼재사용 → GC제거

Q.10. Unity DOTS(ECS, Jobs, Burst)의 핵심 개념과 사용 사례는?
짧은답: 데이터 지향 설계로 캐시 효율과 멀티스레딩을 극대화하며, 대량 오브젝트 시뮬레이션에 적합합니다.
긴답: ECS는 컴포넌트를 연속 메모리에 배치해 캐시 히트율을 높입니다. Job System은 멀티스레드 작업을 안전하게 실행하고, Burst Compiler는 SIMD 최적화된 네이티브 코드를 생성합니다. 총알 수천 개, 군중 시뮬레이션, 절차적 생성 등 대량 연산에 효과적입니다. 학습 곡선이 높아 전체 적용보다 병목 구간에 부분 적용하는 경우가 많습니다.
키워드: 데이터지향 → 캐시효율 → 대량연산

---

## Section 2: C# Deep Dive

Q.11. C#의 Value Type과 Reference Type의 차이, 그리고 struct를 쓸 때 주의점은?
짧은답: Value는 스택 복사, Reference는 힙 참조이며, struct는 16바이트 이하/불변/짧은 수명일 때 적합합니다.
긴답: Value Type은 스택에 값이 복사되고, Reference Type은 힙에 객체가 생성되어 참조가 복사됩니다. struct는 작은 데이터(16바이트 권장), 불변성, 짧은 수명일 때 효율적입니다. 큰 struct는 복사 비용이 크고, 박싱되면 힙 할당이 발생합니다. in/ref 파라미터로 복사를 피할 수 있습니다.
키워드: 스택복사 → 힙참조 → 16바이트규칙

Q.12. C#의 GC(Garbage Collection) 동작 원리와 Unity에서의 최적화 방법은?
짧은답: 세대별 GC로 Gen0/1/2를 관리하며, 풀링/구조체/캐싱으로 할당을 줄여 GC 스파이크를 방지합니다.
긴답: .NET GC는 세대별로 동작해 Gen0(젊은 객체)를 자주, Gen2(오래된 객체)를 드물게 수집합니다. Unity의 Boehm GC는 Stop-the-world로 프레임 스파이크를 유발합니다. 최적화는 오브젝트 풀링, struct 활용, StringBuilder 재사용, LINQ 회피, 컬렉션 미리 할당(capacity)으로 할당 자체를 줄이는 것입니다.
키워드: 세대별수집 → 스파이크 → 할당회피

Q.13. C#의 delegate, event, Action, Func의 차이와 사용 패턴은?
짧은답: delegate가 기본, event는 외부 호출 제한, Action/Func는 미리 정의된 제네릭 델리게이트입니다.
긴답: delegate는 메서드 참조 타입입니다. event는 delegate에 접근 제한을 추가해 외부에서 직접 호출이나 할당을 막습니다. Action은 반환값 없는 델리게이트, Func는 반환값 있는 델리게이트의 제네릭 축약형입니다. Unity에서는 UnityEvent(인스펙터 노출)와 C# event(코드 전용)를 목적에 맞게 구분합니다.
키워드: 메서드참조 → 접근제한 → 제네릭축약

Q.14. C#의 async/await에서 ConfigureAwait(false)는 언제 사용하나요?
짧은답: UI 스레드 복귀가 불필요할 때 사용해 컨텍스트 전환 비용을 줄이고 데드락을 방지합니다.
긴답: await 후 기본적으로 원래 SynchronizationContext로 복귀합니다. 라이브러리나 백그라운드 작업에서 UI 스레드 복귀가 불필요하면 ConfigureAwait(false)로 컨텍스트 전환을 생략합니다. 이는 성능 향상과 데드락 방지에 도움됩니다. 단, Unity 메인 스레드에서 UnityEngine API를 호출해야 하면 사용하면 안 됩니다.
키워드: 컨텍스트복귀 → 비용절감 → 데드락방지

Q.15. SOLID 원칙을 Unity 개발에 어떻게 적용하나요?
짧은답: 컴포넌트 분리(SRP), 상속보다 조합(OCP), 인터페이스 활용(DIP)으로 유지보수성을 높입니다.
긴답: SRP는 하나의 MonoBehaviour가 하나의 책임만 갖게 분리합니다. OCP는 상속보다 조합으로 기능을 확장합니다. LSP는 상속 시 베이스 클래스 계약을 지킵니다. ISP는 작은 인터페이스로 분리(IDamageable, IMovable). DIP는 구체 클래스 대신 인터페이스에 의존해 테스트와 교체를 쉽게 합니다.
키워드: 책임분리 → 조합확장 → 인터페이스의존

Q.16. 디자인 패턴 중 게임 개발에서 자주 쓰이는 것 3가지와 적용 사례는?
짧은답: Singleton(매니저), Observer(이벤트), Object Pool(총알/이펙트)이 대표적입니다.
긴답: Singleton은 GameManager, AudioManager 등 전역 접근이 필요한 시스템에 씁니다(단, 테스트 어려움 주의). Observer는 이벤트 기반 통신으로 UI 업데이트, 상태 변화 알림에 활용합니다. Object Pool은 총알, 이펙트, 적 등 빈번한 생성/파괴 대신 재사용합니다. 추가로 State Pattern(FSM), Command(입력/리플레이), Strategy(AI 행동)도 자주 씁니다.
키워드: 전역접근 → 이벤트통신 → 오브젝트재사용

Q.17. C#의 ref, out, in 키워드의 차이와 사용 시점은?
짧은답: ref는 양방향, out은 출력 전용, in은 읽기 전용 참조로 큰 struct 전달에 유용합니다.
긴답: ref는 초기화된 값을 전달하고 메서드 내에서 수정 가능합니다. out은 초기화 없이 전달하고 메서드에서 반드시 할당해야 합니다. in은 읽기 전용으로 전달해 복사를 피하면서 수정을 막습니다. 큰 struct(Vector3, Matrix4x4)를 반복 호출할 때 in으로 전달하면 복사 비용을 줄일 수 있습니다.
키워드: 양방향 → 출력전용 → 읽기전용

Q.18. C#의 Span<T>와 Memory<T>의 용도와 Unity에서의 활용은?
짧은답: 힙 할당 없이 배열/메모리 구간을 참조하며, 파싱/직렬화/NativeArray 연동에 활용합니다.
긴답: Span<T>는 스택 전용으로 배열이나 메모리의 연속 구간을 할당 없이 참조합니다. Memory<T>는 힙에 저장 가능해 async 메서드에서 사용됩니다. Unity에서는 NativeArray와 연동해 Job System 데이터 처리, JSON/바이너리 파싱에서 substring 대신 Slice로 할당을 피하는 데 활용합니다.
키워드: 무할당참조 → 구간슬라이스 → 네이티브연동

---

## Section 3: Game Development General

Q.19. 게임 루프(Game Loop)의 구조와 고정 시간 스텝 vs 가변 시간 스텝의 차이는?
짧은답: 고정 스텝은 물리/게임플레이 일관성, 가변 스텝은 렌더링 부드러움에 사용합니다.
긴답: 게임 루프는 입력→업데이트→렌더링의 반복입니다. 고정 시간 스텝(Fixed Timestep)은 물리/게임 로직에 일관된 시뮬레이션을 보장하고, 가변 스텝(Delta Time)은 프레임 속도에 맞춰 부드러운 렌더링을 제공합니다. Unity는 FixedUpdate(고정)와 Update(가변)를 분리해 두 방식을 조합합니다.
키워드: 일관성 → 부드러움 → 분리조합

Q.20. 클라이언트-서버 동기화에서 State Sync와 Input Sync의 차이는?
짧은답: State Sync는 서버가 상태를 브로드캐스트, Input Sync는 입력만 전송하고 각자 시뮬레이션합니다.
긴답: State Synchronization은 서버가 권위를 가지고 게임 상태를 클라이언트에 전송합니다. 구현이 간단하지만 대역폭이 큽니다. Input Synchronization(Lockstep)은 입력만 공유하고 모든 클라이언트가 동일하게 시뮬레이션합니다. 결정론적 시뮬레이션이 필요하고 대역폭은 적지만 구현 난이도가 높습니다. RTS는 Lockstep, FPS/액션은 State Sync+예측이 일반적입니다.
키워드: 상태전송 → 입력공유 → 결정론

Q.21. 네트워크 지연 보상 기법(Lag Compensation)의 종류와 원리는?
짧은답: Client Prediction, Server Reconciliation, Entity Interpolation으로 지연을 숨깁니다.
긴답: Client Prediction은 서버 응답 전에 클라이언트가 먼저 행동을 예측합니다. Server Reconciliation은 서버 응답이 오면 클라이언트 상태를 보정합니다. Entity Interpolation은 다른 플레이어를 과거 두 상태 사이에서 보간해 부드럽게 표시합니다. FPS에서는 히트 판정 시 서버가 과거 시점으로 되돌려(Rewind) 검증하기도 합니다.
키워드: 예측 → 보정 → 보간

Q.22. A* 알고리즘의 원리와 게임에서의 최적화 방법은?
짧은답: f = g + h로 최적 경로를 탐색하며, Hierarchical Pathfinding, JPS, NavMesh로 최적화합니다.
긴답: A*는 시작점에서의 실제 비용(g)과 목표까지 예상 비용(h, 휴리스틱)의 합(f)이 가장 작은 노드를 우선 탐색합니다. 게임에서는 맵이 커지면 비용이 급증하므로 NavMesh(Unity 내장), Hierarchical Pathfinding(영역 단위 탐색), Jump Point Search(직선 구간 스킵)로 최적화합니다. 동적 장애물은 Local Avoidance(RVO)와 조합합니다.
키워드: 휴리스틱 → 계층탐색 → NavMesh

Q.23. Behavior Tree와 FSM(Finite State Machine)의 차이와 선택 기준은?
짧은답: FSM은 상태 전이 기반으로 단순, BT는 트리 구조로 복잡한 AI에 확장성이 좋습니다.
긴답: FSM은 상태와 전이로 구성되어 직관적이지만 상태가 많아지면 전이 폭발(State Explosion)이 발생합니다. Behavior Tree는 Selector/Sequence/Decorator로 구성되어 모듈화와 재사용이 쉽고 복잡한 AI에 적합합니다. 단순 캐릭터는 FSM, 복잡한 보스/동료 AI는 BT, 상황에 따라 HFSM(계층 FSM)도 사용합니다.
키워드: 전이기반 → 트리구조 → 확장성

Q.24. 프로시저럴 생성(Procedural Generation)의 주요 기법과 사례는?
짧은답: Perlin Noise(지형), Wave Function Collapse(던전), L-System(식물)이 대표적입니다.
긴답: Perlin/Simplex Noise는 연속적인 난수로 자연스러운 지형/동굴을 생성합니다. Wave Function Collapse는 규칙 기반으로 타일을 배치해 던전/도시를 만듭니다. L-System은 재귀 문법으로 식물/나무를 생성합니다. 로그라이크, 서바이벌 장르에서 리플레이성을 높이는 데 핵심 기술입니다.
키워드: 노이즈 → 규칙기반 → 재귀문법

Q.25. 셰이더 최적화의 주요 기법과 모바일에서의 고려사항은?
짧은답: ALU 연산 최소화, 텍스처 샘플 줄이기, 프래그먼트 복잡도 제어가 핵심입니다.
긴답: 정점 셰이더에서 가능한 연산을 하고 프래그먼트로 넘기는 것이 효율적입니다. 모바일에서는 half precision 사용, 분기문 최소화, 알파 테스트 대신 알파 블렌딩, 오버드로우 제어가 중요합니다. 타일 기반 렌더링(TBDR)을 고려해 Early-Z가 깨지는 상황을 피하고, 복잡한 수학(pow, sin)을 LUT 텍스처로 대체합니다.
키워드: ALU절감 → half정밀도 → 오버드로우

Q.26. 물리 엔진의 Discrete vs Continuous Collision Detection의 차이는?
짧은답: Discrete는 매 스텝 위치만 검사, Continuous는 궤적을 검사해 빠른 물체의 터널링을 방지합니다.
긴답: Discrete Detection은 매 물리 스텝에서 현재 위치만 검사하므로 빠른 물체가 얇은 벽을 통과(터널링)할 수 있습니다. Continuous Detection은 이전-현재 위치 사이 궤적을 검사해 터널링을 방지합니다. 비용이 높으므로 총알, 빠른 투사체에만 선택적으로 적용합니다. Unity에서는 Rigidbody의 Collision Detection 옵션으로 설정합니다.
키워드: 위치검사 → 궤적검사 → 터널링방지

Q.27. 게임에서 물리와 렌더링 프레임이 다를 때 보간(Interpolation)이 필요한 이유는?
짧은답: 물리는 고정 스텝, 렌더링은 가변이라 위치 점프를 부드럽게 하려면 보간이 필요합니다.
긴답: FixedUpdate(50Hz)와 렌더링(60Hz 이상)이 다르면 오브젝트 위치가 끊겨 보입니다. 이전 물리 위치와 현재 위치 사이를 렌더링 시점에 보간하면 부드러운 움직임이 됩니다. Unity의 Rigidbody.interpolation 옵션이 이를 처리합니다. 네트워크 게임에서도 서버 상태 사이를 보간해 끊김을 숨깁니다.
키워드: 스텝불일치 → 끊김 → 부드러운보간

Q.28. LOD(Level of Detail) 시스템의 원리와 구현 방식은?
짧은답: 카메라 거리에 따라 메시/텍스처 품질을 낮춰 성능을 확보합니다.
긴답: 멀리 있는 오브젝트는 디테일이 덜 보이므로 저폴리곤 메시로 교체해 렌더링 비용을 줄입니다. Unity LOD Group으로 거리별 메시를 설정하고, 추가로 HLOD(Hierarchical LOD)로 먼 거리에서 여러 오브젝트를 하나로 합칩니다. 텍스처 MipMap도 같은 원리로 메모리/대역폭을 절약합니다.
키워드: 거리기반 → 메시교체 → 비용절감

---

## Section 4: Architecture & System Design

Q.29. 게임 아키텍처에서 Manager 클래스 남발의 문제점과 대안은?
짧은답: 전역 상태와 강한 결합이 문제이며, 이벤트 버스, DI, 서비스 로케이터로 분리합니다.
긴답: Manager 싱글톤이 많아지면 전역 상태가 증가하고 테스트가 어려워지며 의존성이 숨겨집니다. 대안으로 이벤트 버스(Observer)로 통신을 분리하고, Dependency Injection으로 의존성을 명시화합니다. Service Locator는 중간 단계 해결책이며, 궁극적으로는 인터페이스 기반 설계로 결합도를 낮춥니다.
키워드: 전역상태 → 테스트어려움 → 의존성분리

Q.30. ECS(Entity-Component-System) 패턴의 장단점과 전통 OOP와의 차이는?
짧은답: ECS는 데이터 지향으로 캐시 효율/병렬화가 좋지만 직관성이 떨어지고 학습 곡선이 높습니다.
긴답: 전통 OOP는 객체에 데이터+행동이 함께 있어 직관적이지만 상속 계층이 복잡해지고 캐시 미스가 많습니다. ECS는 Entity(ID), Component(데이터), System(로직)을 분리해 데이터가 연속 메모리에 배치되어 캐시 효율적이고 병렬 처리에 유리합니다. 단점은 전통적 사고방식과 달라 적응이 필요하고, 모든 게임에 적합하지는 않습니다.
키워드: 데이터분리 → 캐시효율 → 학습곡선

Q.31. 게임에서 모듈 간 통신 방법(직접 참조, 이벤트, 메시지 버스)의 트레이드오프는?
짧은답: 직접 참조는 빠르지만 결합도 높음, 이벤트는 느슨하지만 디버깅 어려움, 상황에 맞게 혼용합니다.
긴답: 직접 참조는 성능이 좋고 명확하지만 결합도가 높아 변경에 취약합니다. 이벤트/델리게이트는 느슨한 결합이지만 흐름 추적이 어렵습니다. 메시지 버스는 완전히 분리되지만 타입 안전성이 떨어질 수 있습니다. 보통 핵심 게임플레이는 직접 참조, UI나 시스템 간 통신은 이벤트, 대규모 시스템은 메시지 버스를 혼용합니다.
키워드: 결합도 → 추적성 → 상황별혼용

Q.32. 게임 세이브 시스템 설계 시 고려사항은?
짧은답: 직렬화 포맷, 버전 호환, 무결성 검증, 암호화, 비동기 저장을 고려합니다.
긴답: 직렬화는 JSON(가독성)/Binary(성능)/ScriptableObject(에디터 친화)를 목적에 맞게 선택합니다. 버전 호환을 위해 스키마 버전을 포함하고 마이그레이션 로직을 둡니다. 체크섬으로 손상을 감지하고, 민감 데이터는 암호화합니다. 저장은 비동기로 처리해 프레임 드랍을 방지하고, 임시 파일 후 원자적 교체로 데이터 손실을 막습니다.
키워드: 버전호환 → 무결성 → 비동기저장

Q.33. 핫 리로드(Hot Reload) / 라이브 튜닝 시스템의 설계 방법은?
짧은답: 데이터와 코드를 분리하고, 파일 감시→파싱→적용 파이프라인을 구축합니다.
긴답: 게임 데이터(밸런스, 설정)를 JSON/ScriptableObject로 분리합니다. FileSystemWatcher나 에디터 훅으로 변경을 감지하고, 런타임에 다시 로드해 적용합니다. 반영 시점을 제어해 게임 중단 없이 적용하거나, 스테이지 전환 시 적용하도록 합니다. 기획자가 빌드 없이 밸런싱할 수 있어 개발 속도가 크게 향상됩니다.
키워드: 데이터분리 → 파일감시 → 빌드없이튜닝

Q.34. 멀티플레이 게임에서 치트 방지(Anti-Cheat) 전략은?
짧은답: 서버 권위(Server Authority), 입력 검증, 비정상 패턴 감지, 암호화가 기본입니다.
긴답: 서버가 모든 게임 로직의 권위를 가져 클라이언트 조작을 무시합니다. 입력의 물리적 가능성(이동 속도, 연사 속도)을 서버에서 검증합니다. 통계 기반으로 비정상 패턴(정확도, 반응 시간)을 감지합니다. 패킷 암호화와 메모리 무결성 검사를 추가하고, 최종적으로 신고 시스템과 리플레이 검증을 조합합니다.
키워드: 서버권위 → 입력검증 → 패턴감지

---

## Section 5: Collaboration & Process

Q.35. 기획자/아티스트와 협업할 때 개발자로서 중요하게 생각하는 것은?
짧은답: 명확한 커뮤니케이션, 빠른 프로토타입, 제약 사항의 솔직한 공유입니다.
긴답: 기술 용어 대신 결과물 중심으로 소통하고, 가능하면 빠른 프로토타입으로 보여줍니다. 기술적 제약이나 비용은 숨기지 않고 대안과 함께 제시합니다. 기획/아트 의도를 먼저 이해한 후 구현 방법을 제안하고, "안 된다" 대신 "이렇게 하면 된다"로 대화합니다.
키워드: 결과물중심 → 빠른검증 → 대안제시

Q.36. 코드 리뷰에서 중요하게 보는 항목과 리뷰어로서의 원칙은?
짧은답: 로직 정확성, 성능 이슈, 확장성, 코드 스타일 순으로 보고, 비판이 아닌 개선 제안을 합니다.
긴답: 먼저 의도와 요구사항 충족을 확인하고, 버그 가능성/엣지 케이스를 찾습니다. 그 다음 성능 문제(GC, 복잡도)와 확장성을 봅니다. 스타일/네이밍은 자동 도구에 맡기고, 리뷰어로서 "왜 이렇게 했는지" 물으며 배우는 자세를 유지합니다. 칭찬할 부분도 언급하고, 개선 사항은 이유와 함께 제안합니다.
키워드: 의도파악 → 버그탐색 → 건설적제안

Q.37. 레거시 코드를 리팩토링할 때의 접근 방법은?
짧은답: 테스트 추가 → 작은 단위 개선 → 점진적 교체로 안전하게 진행합니다.
긴답: 먼저 현재 동작을 보장하는 테스트(특히 통합 테스트)를 추가합니다. 전체 재작성보다 작은 단위로 개선하며, Strangler Fig 패턴으로 새 코드를 점진적으로 끼워 넣습니다. Boy Scout Rule(왔을 때보다 깨끗하게)을 적용하고, 리팩토링과 기능 추가를 같은 커밋에 섞지 않습니다.
키워드: 테스트먼저 → 점진적개선 → 분리커밋

Q.38. 게임 개발에서 CI/CD 파이프라인 구성 시 포함되어야 할 단계는?
짧은답: 빌드 → 테스트 → 정적 분석 → 아티팩트 업로드 → 배포(스테이징/프로덕션) 순서입니다.
긴답: 코드 푸시 시 자동으로 빌드(멀티 플랫폼)하고, 유닛/통합 테스트를 실행합니다. 정적 분석으로 코드 품질을 체크하고, 성공 시 빌드 아티팩트를 저장소에 업로드합니다. 스테이징 환경에 자동 배포하고, 승인 후 프로덕션에 배포합니다. Unity Cloud Build나 Jenkins/GitHub Actions를 활용합니다.
키워드: 자동빌드 → 테스트 → 단계별배포

Q.39. 크런치(Crunch) 없이 마감을 지키기 위한 개발자의 전략은?
짧은답: 스코프 조정, 조기 위험 공유, MVP 우선, 버퍼 확보가 핵심입니다.
긴답: 마감 전에 "완성 가능한 범위"를 솔직하게 산정하고 스코프를 조정합니다. 위험 요소는 발견 즉시 공유해 결정을 빠르게 합니다. MVP(최소 기능)를 먼저 완성해 핵심 경험을 확보하고 나머지는 시간에 따라 추가합니다. 일정에 버퍼를 두고, 예측 가능한 속도로 일해 신뢰를 쌓습니다.
키워드: 스코프관리 → 조기공유 → MVP우선

Q.40. 기술 부채(Technical Debt)를 관리하는 방법과 갚아야 할 시점은?
짧은답: 문서화→정량화→스프린트에 포함으로 관리하고, 개발 속도가 눈에 띄게 느려질 때 갚습니다.
긴답: 부채를 백로그에 기록하고 영향도를 정량화합니다. 매 스프린트에 일정 비율(예: 20%)을 부채 상환에 할당합니다. "나중에" 하려면 잊혀지므로 바로 기록합니다. 갚아야 할 시점은 새 기능 추가가 어려워지거나, 버그 수정이 연쇄 반응을 일으키거나, 온보딩이 오래 걸릴 때입니다.
키워드: 기록정량화 → 정기상환 → 속도저하시

---

## Section 6: Problem Solving & Debugging

Q.41. 재현이 어려운 버그를 디버깅하는 접근 방법은?
짧은답: 로그 강화, 조건 좁히기, 의심 코드 격리, 확률적 재현 자동화로 접근합니다.
긴답: 먼저 관련 구간에 상세 로그를 추가합니다. 발생 조건(시간, 입력, 상태)을 좁혀가며 패턴을 찾습니다. 의심 코드를 격리해 최소 재현 케이스를 만듭니다. 레이스 컨디션이 의심되면 스레드 분석 도구를 사용하고, 확률적 버그는 자동화 테스트로 대량 반복해 재현합니다.
키워드: 로그강화 → 조건축소 → 격리재현

Q.42. 성능 프로파일링 시 가장 먼저 확인하는 지표와 도구는?
짧은답: CPU(메인 스레드 시간), GPU(드로우콜), 메모리(GC) 순으로 Unity Profiler를 확인합니다.
긴답: Unity Profiler에서 먼저 프레임 시간을 확인하고 CPU vs GPU 바운드를 판단합니다. CPU면 호출 스택에서 병목 함수를 찾고, GPU면 렌더링 스탯에서 드로우콜/필레이트를 봅니다. Memory Profiler로 GC Alloc과 힙 크기를 확인합니다. Frame Debugger로 렌더링 순서를, Deep Profile로 세부 함수 비용을 분석합니다.
키워드: 프레임분석 → 병목판단 → 도구활용

Q.43. 모바일에서 발열/배터리 소모를 줄이는 최적화 전략은?
짧은답: 타겟 프레임 제한, 백그라운드 처리 최소화, GPU/CPU 부하 분산이 핵심입니다.
긴답: Application.targetFrameRate을 30-60으로 제한해 불필요한 연산을 줄입니다. 백그라운드에서 로직을 최소화하고, 배터리 모드에서 품질을 낮춥니다. 과도한 파티클, 실시간 그림자, 포스트 프로세싱을 제거합니다. CPU와 GPU 부하를 프레임에 분산하고, 아이들 시간에 Sleep을 넣습니다.
키워드: 프레임제한 → 백그라운드최소 → 부하분산

Q.44. 크래시 덤프/로그 분석 경험과 접근 방법은?
짧은답: 스택 트레이스로 위치 파악, 심볼 파일로 디버깅, 재현 조건 추적 순으로 분석합니다.
긴답: 크래시 리포트에서 스택 트레이스를 확인하고 충돌 위치를 파악합니다. 심볼 파일(.pdb, .sym)로 원본 코드 라인을 매핑합니다. 메모리 덤프가 있으면 WinDbg/lldb로 분석합니다. 발생 빈도, 디바이스, OS 버전을 수집해 패턴을 찾고, 원인 가설을 세워 수정 후 배포합니다.
키워드: 스택추적 → 심볼매핑 → 패턴분석

Q.45. "프레임 드랍이 발생한다"는 리포트를 받았을 때 어떻게 대응하나요?
짧은답: 재현 확보 → 프로파일러 측정 → 병목 식별 → 최적화 → 검증 순서로 대응합니다.
긴답: 먼저 재현 조건(디바이스, 해상도, 씬, 상황)을 확보합니다. Profiler로 실제 프레임 시간을 측정하고 CPU/GPU/메모리 중 병목을 식별합니다. 가장 큰 비용부터 최적화하고, 변경 전후를 수치로 비교합니다. 다양한 디바이스에서 검증하고, 리그레션 방지를 위해 성능 테스트를 자동화합니다.
키워드: 재현확보 → 측정식별 → 수치검증

---

## Section 7: Career & Growth

Q.46. 시니어 개발자로서 주니어와 협업할 때 중요하게 생각하는 것은?
짧은답: 코드 리뷰로 성장 기회 제공, 질문 환경 조성, 점진적 책임 부여입니다.
긴답: 리뷰는 지적이 아닌 학습 기회로, "왜 이렇게 했는지" 대화하며 사고 과정을 공유합니다. 질문하기 편한 환경을 만들고, "모른다"를 부끄럽지 않게 합니다. 처음엔 작은 태스크, 점차 복잡한 것으로 책임을 늘리고, 성공 경험을 쌓게 합니다. 문서화를 함께해 지식을 공유합니다.
키워드: 학습기회 → 안전환경 → 점진적책임

Q.47. 기술 트렌드를 따라가기 위해 어떤 노력을 하나요?
짧은답: 공식 문서, GDC/Unite, 오픈소스, 사이드 프로젝트, 커뮤니티 참여로 학습합니다.
긴답: Unity 공식 블로그와 로드맵을 정기적으로 확인합니다. GDC, Unite 세션을 보고, 관심 분야 오픈소스를 읽습니다. 새 기술은 사이드 프로젝트로 직접 써보고, 커뮤니티(Discord, 포럼)에서 토론합니다. 너무 많이 쫓기보다 프로젝트에 필요한 것 위주로 깊게 파고, 기초 원리를 우선합니다.
키워드: 공식채널 → 실습검증 → 깊이우선

Q.48. 과거 프로젝트에서 가장 어려웠던 기술적 문제와 해결 과정은?
짧은답: (개인 경험 기반) 문제 정의 → 가설 수립 → 실험 → 해결의 구조로 답변합니다.
긴답: "프로젝트 X에서 Y 문제가 있었습니다. 증상은 Z였고, 처음엔 A라고 생각했지만 조사 결과 B가 원인이었습니다. C 방법으로 해결했고, 결과적으로 D만큼 개선되었습니다. 이 경험으로 E를 배웠습니다."의 구조로 구체적 수치와 함께 답변합니다.
키워드: STAR구조 → 구체적수치 → 교훈도출

Q.49. 5년 후 어떤 개발자가 되고 싶은가요?
짧은답: 기술 깊이와 리더십을 겸비해 팀 전체의 생산성을 높이는 개발자가 되고 싶습니다.
긴답: 특정 도메인(예: 렌더링, 네트워크, 툴)에서 깊은 전문성을 갖추면서, 팀의 기술 방향을 설계하고 이끌 수 있는 역할을 목표로 합니다. 주니어 성장을 돕고, 기술 부채를 줄이며, 프로젝트 성공에 실질적으로 기여하는 개발자가 되고 싶습니다.
키워드: 전문성심화 → 팀기여 → 기술리더십

Q.50. 이 회사/프로젝트에 지원한 이유와 기여할 수 있는 점은?
짧은답: (회사 연구 기반) 프로젝트 특성과 본인 경험의 교집합을 구체적으로 연결합니다.
긴답: "귀사의 X 프로젝트에서 Y 기술을 사용하는 것을 보고 제 Z 경험이 기여할 수 있다고 생각했습니다. 특히 A 분야에서 B 성과를 냈던 경험으로, 귀사의 C 목표 달성에 도움이 될 수 있습니다. 또한 D 분야를 더 배우고 싶어 지원했습니다."
키워드: 회사연구 → 경험연결 → 상호성장

---

## Bonus: Behavioral / Situational Questions

Q.B1. 팀원과 기술적 의견 충돌이 있을 때 어떻게 해결하나요?
짧은답: 데이터/프로토타입으로 검증하고, 합의가 안 되면 작은 실험 후 결과로 판단합니다.
긴답: 먼저 상대 의견의 장점을 인정하고 이해하려 합니다. 감정이 아닌 데이터(벤치마크, 사례)로 논의하고, 가능하면 프로토타입으로 비교합니다. 합의가 어려우면 작은 범위로 실험해 결과로 판단합니다. 최종 결정 후에는 합의 사항을 문서화하고 전적으로 따릅니다.
키워드: 이해먼저 → 데이터검증 → 결정후지지

Q.B2. 일정이 촉박한데 기술적으로 올바르지 않은 방법을 요청받으면?
짧은답: 리스크를 명확히 공유하고, 단기 해결책과 장기 개선 계획을 함께 제안합니다.
긴답: "이 방법의 리스크는 X이고, 나중에 Y 비용이 발생합니다"를 명확히 전달합니다. 대안이 있으면 비용 비교와 함께 제안하고, 불가피하면 기술 부채로 기록해 나중에 반드시 갚겠다고 합의합니다. 단, 보안/데이터 무결성 문제는 타협하지 않습니다.
키워드: 리스크공유 → 대안제시 → 타협불가선

Q.B3. 새로운 기술을 도입하고 싶을 때 어떻게 설득하나요?
짧은답: PoC로 효과를 증명하고, 리스크와 롤백 계획을 함께 제시합니다.
긴답: 먼저 왜 필요한지(문제 정의)를 명확히 하고, 소규모 PoC(Proof of Concept)로 효과를 증명합니다. 학습 비용, 리스크, 롤백 계획을 함께 제시해 불확실성을 줄입니다. 팀원들과 스터디를 통해 공감대를 형성하고, 점진적 도입을 제안합니다.
키워드: 문제정의 → PoC증명 → 점진도입

Q.B4. 번아웃을 경험했거나 예방하기 위해 하는 것은?
짧은답: 업무 외 시간 확보, 작은 성취 인식, 도움 요청을 부끄러워하지 않습니다.
긴답: 퇴근 후와 주말에는 업무를 끊고 취미나 휴식에 집중합니다. 큰 목표를 작은 마일스톤으로 나눠 성취감을 자주 느끼게 합니다. 혼자 안고 있지 않고 어려움을 팀과 공유하며, 필요하면 휴가를 사용합니다. 장기적으로 지속 가능한 페이스가 더 높은 생산성을 만든다고 생각합니다.
키워드: 경계설정 → 작은성취 → 지속가능성

Q.B5. 가장 자랑스러운 기술적 성취와 그 이유는?
짧은답: (개인 경험) 문제 정의, 해결 과정, 임팩트, 배운 점을 구체적으로 설명합니다.
긴답: "프로젝트 X에서 Y 문제를 해결한 것이 가장 자랑스럽습니다. 기존에는 Z 상황이었는데, A 접근법으로 B 결과를 얻었습니다. 이로 인해 C (정량적 개선)가 있었고, 팀에서 D로 활용되었습니다. 이 경험으로 E 역량을 키웠습니다."
키워드: 구체적맥락 → 정량적결과 → 성장연결
