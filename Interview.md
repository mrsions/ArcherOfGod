## 🧪 면접 전 체크리스트(필수)
- 화면 공유: 게임 창 해상도 `1280x720` 고정, 알림 끄기.
- 입력 장치: 키보드·마우스 동작 확인, 포커스 전환 시 입력 끊김 재현 테스트.
- 빌드/씬: 시작 씬 바로 실행되게 설정, 실패 시 대체 경로(에디터 실행) 준비.
- 퍼포먼스: 프로파일러 프리셋(메인스레드/GC/렌더링) 저장, 데모 중 FPS 표시 온.
- 복구 스위치: `R`(리셋), `F1`(슬로우모션 토글) 등 시연 단축키 안내.

### 코드 컨벤션(시연 중 짧게 언급 권장)
- 로그 메시지: 영어 사용(예: `"State Changed: Battle -> Result"`).
- 주석: 한국어 사용(의도·맥락 중심으로 간결히).

## 🗣 발표 스크립트(시간대별 베이스라인)

### 30초
- 한 줄: “4일동안 안에 1v1 전투와 5개 스킬을 완주했고, 상태·이벤트·스킬 확장을 표준화해 ‘추가가 쉬운 구조’를 만들었습니다.”
- 근거: 상태머신 + OnChanged 이벤트, BaseSkill 확장, 풀링 + UniTask로 GC·지연 최소화.
- 효과: UI/게임 로직 결합도 하락, 신규 스킬/연출 추가 시 리스크 낮음.

### 3분
- 목표: 짧은 시간 내 완주 가능한 ‘한 판 경험’ 우선.
- 핵심 설계: GameManager(상태) → OnChanged 이벤트(결합↓) → BaseSkill(확장) → 애니메이션 이벤트 동기화.
- 성능: 오브젝트 풀 + UniTask cancel로 ‘멈추면 즉시 정리’, 프레임 드랍/메모리 급증 방지.
- 결과: 스크립트 33개·약 4,000라인, 입력 3종(키보드/마우스/패드), 7개 성능 포인트.

### 10분
- 문제정의: “시간제한 내 검증 가능한 재미”를 위한 절차(흐름 파악→체감 강화→안정화).
- 구현 상세: 상태 다이어그램, 스킬 베이스/구상, 애니메이션 이벤트 단계(Prepare→Shot→End), UI 동기, 에러 복구 플로우.
- 트레이드오프: 단일 전투 집중(깊이↑/범위↓), 동적 연출 최소화 대신 피드백 강화.
- 시연: 1) 매치 시작 → 2) 스킬 시연(각 5~8초) → 3) HP/피격/승패 → 4) 리셋.

## 📊 지표·수치 원페이지(면접용 읽기 자료)
- 기간/공수: 4일/32시간.
- 규모: 33 스크립트 / 총 ~4,000 라인.
- 플레이: 1v1, 스킬 5개, 입력 3종(키보드/마우스/패드).
- 안정화: 7개 성능 포인트, 오브젝트 풀링 + UniTask cancel.
- 구조 효과: UI·로직 결합↓, 신규 스킬 추가/테스트 시간↓, 연출 동기 일관성↑.

## 🎮 라이브 데모 플로우(타임라인)
1) 타이틀/대기 → 2) 전투 진입 → 3) 스킬 1~5 순차 시연(각 5~8초) → 4) 피격·HP·승패 확인 → 5) `R` 리셋 → 6) 질의응답.

## ⚖️ 리스크·트레이드오프 요약
- 풀링 vs 메모리 점유: ‘즉시 재사용’을 택해 스파이크를 줄임(메모리 상한 관리 필요).
- UniTask vs Coroutine: 가독성/취소 제어 강화(팀 패턴·코드리뷰 체크리스트로 일관성 보장).
- 상태/이벤트 분리: 결합도↓(상태 전환 로그·이벤트 로그 표준화로 디버깅 관측성↑).

## 🔎 Q&A 한줄 무기(업데이트)
- “추가가 쉬운 구조”를 증명: 신규 스킬 틀(BaseSkill) + 이벤트 동기화 + UI 자동 반영.
- “멈추면 정리” 원칙: cancel 토큰·풀링으로 중단 즉시 누수와 스파이크 차단.
- “결합↓, 관측↑”: OnChanged 이벤트/해시 정규화/상태 전환 로그로 디버깅 축 약화.

---

# 🎯 1페이지 요약 (면접 직전 복습용)

## 0) 30초 요약 (그대로 말하기)

> **"이건 4일(32시간) 안에 플레이 가능한 1v1 액션을 완성한 과제입니다.**
> 게임 흐름은 **상태머신**으로 관리하고, UI/로직은 **이벤트 기반**으로 분리했습니다.
> 스킬은 **추상/템플릿 구조**로 확장 가능하게 만들었고, 발사 타이밍은 **애니메이션 이벤트**로 동기화했습니다.
> 투사체는 **3차 베지어 + 유도 전환**으로 차별점을 넣었고, 성능은 **오브젝트 풀링 + UniTask 취소 토큰**으로 GC/누수 리스크를 줄였습니다.
> 입력은 **Input System**으로 키보드/터치/게임패드를 지원합니다."

---

## 1) 핵심 숫자/스펙 (암기)

```
⏱️ 4일 / 32시간
📄 33개 스크립트 / 약 4,000 라인
🎮 1v1 전투 + 5개 스킬
🎯 입력 3종: 키보드 / 터치 / 게임패드
📊 7개 게임 상태
🔧 5개 디자인 패턴 (상태머신, 이벤트, 템플릿메서드, 풀, 전략)
```

---

## 2) TOP5 결정 카드 (결론→이유→구현→효과)

### 카드1) 게임 상태 관리 (GameManager)
| 항목 | 내용 |
|------|------|
| **결론** | 상태 머신으로 게임 흐름을 관리했습니다 |
| **이유** | 흐름이 늘어도 복잡도가 폭발하지 않게 분리하려고 |
| **구현** | `EGameStatus` enum + `OnChangedStatus` 이벤트 발행 |
| **효과** | UI/시스템이 독립적으로 반응, 상태 추가가 쉬움 |

### 카드2) 이벤트 기반 통신 (OnChanged*)
| 항목 | 내용 |
|------|------|
| **결론** | 컴포넌트 간 통신을 이벤트로 통일했습니다 |
| **이유** | UI-로직 결합도를 낮추고 교체/테스트를 쉽게 하려고 |
| **구현** | `event Action<T>` + `?.Invoke()` 패턴 |
| **효과** | HP/Power/Status 변경 → UI 자동 갱신, 사이드 이펙트 감소 |

### 카드3) 스킬 확장 구조 (BaseSkillBehaviour)
| 항목 | 내용 |
|------|------|
| **결론** | 스킬을 추상/템플릿 구조로 만들었습니다 |
| **이유** | 새 스킬 추가를 "상속 + 최소 구현"으로 끝내려고 |
| **구현** | Base에서 쿨타임/상태 공통, 파생에서 발사/효과 구현 |
| **효과** | 5개 스킬이 동일 프레임으로 동작, 확장 속도 빠름 |

### 카드4) 애니메이션 이벤트 동기화
| 항목 | 내용 |
|------|------|
| **결론** | 스킬 타이밍을 애니메이션 이벤트로 제어했습니다 |
| **이유** | 시각 피드백과 판정/발사 타이밍을 정확히 맞추려고 |
| **구현** | `Prepare → Shot → End` 이벤트 체인 |
| **효과** | "쏘는 순간"이 자연스럽고 일관됨 (체감 품질 상승) |

### 카드5) 투사체 차별점 + 성능 안정화
| 항목 | 내용 |
|------|------|
| **결론** | 투사체는 3차 베지어 기반, 필요 시 유도로 전환했습니다 |
| **이유** | 직선보다 자연스러운 궤적 + 특수 스킬 표현을 위해 |
| **구현** | `FBezier.Evaluate(t)` + `m_GuideArrowStart` 이후 방향 보간 |
| **효과** | 베지어→유도 전환 자연스러움, **풀링+UniTask cancel**로 GC/누수 감소 |

---

## 3) 성능/안정성 한 줄 어필

| 항목 | 설명 |
|------|------|
| **풀링** | `Rent/Return`로 생성/파괴 최소화 → 프레임 안정 |
| **UniTask** | `destroyCancellationToken`로 오브젝트 파괴 시 자동 취소 → 누수/예외 방지 |
| **Animator Hash** | 문자열 비용 제거 (매 프레임 부담 최소화) |

---

## 4) {회사} 가치 연결

| {회사} 가치 | 내 프로젝트 |
|-----------|------------|
| **빠름** | 4일/32시간 내 완성, 우선순위 기반 컷 |
| **심플** | 1v1 핵심 루프 (이동+스킬) 명확 |
| **다름** | 베지어 투사체 / 랜덤 요소로 차별점 |
| **유저 중심** | 입력 크로스플랫폼 + 직관적 UI 바인딩 |

---

## 5) 아쉬운 점 & 로드맵 (성숙함 보여주는 파트)

| 항목 | 현재 | 개선 방향 |
|------|------|----------|
| **AI** | 랜덤 | 궤적 예측/회피/거리 기반 의사결정 |
| **데이터** | 하드코딩 | SO/JSON 외부화 + 밸런싱 파이프라인 |
| **네트워크** | 로컬 | PvP 확장 (Photon/Netcode) 설계 가능 |
| **테스트** | 수동 | 핵심 로직 유닛 테스트 / 리그레션 체크리스트 |
| **버그** | `idx == null` | null/범위 방어 규칙 정리 |

---

## 6) 프로젝트 구조

### 전체 폴더 구조
```
Assets/AOG/
├── Animations/           # 애니메이션 클립 및 컨트롤러
│   ├── Peasant/          # 캐릭터 애니메이션 (idle, walk, attack, skills)
│   └── UI/               # UI 애니메이션 (스킬버튼, 데미지텍스트, 상태창)
├── Prefab/               # 프리팹 에셋
│   ├── Arrow/            # 화살 프리팹 (Arrow, ArrowProjectile)
│   ├── Characters/       # 캐릭터 프리팹 (Character, PlayerCharacter)
│   └── UI/               # UI 프리팹 (Skill_1~5, Controller, PlayerStatus)
├── Resources/            # 런타임 로드 에셋
│   └── GameSettings.asset # 게임 설정값 (시간, 딜레이 등)
├── Scenes/               # 씬 파일
│   └── Game.unity        # 메인 게임 씬
├── Scripts/Runtime/      # 소스 코드 (33개 파일, ~4000 라인)
│   └── ArcherOfGod/      # 핵심 게임 로직
└── UI/Atlas/             # UI 스프라이트 에셋
```

### 스크립트 폴더 구조 (책임 기반 분류)
```
Scripts/Runtime/ArcherOfGod/
│
├── [Root]                 # 전역 시스템
│   ├── GameManager.cs         # 게임 상태 머신, 승패 판정
│   ├── GameSettings.cs        # 설정값 ScriptableObject
│   ├── GameLoader.cs          # 씬 로딩/전환
│   └── Startup.cs             # 진입점 초기화
│
├── Behaviours/            # 핵심 게임 오브젝트 (상속 계층)
│   ├── ObjectBehaviour.cs     # Base: HP/Shield, 피격/공격 처리
│   ├── CharacterBehaviour.cs  # 이동, 스킬 실행, 애니메이션
│   └── ProjectileBehaviour.cs # 베지어 비행, 충돌, 풀링 연동
│
├── Skills/                # 스킬 시스템 (템플릿 메서드 패턴)
│   ├── BaseSkillBehaviour.cs  # Abstract: 쿨타임, 상태 관리
│   └── ArrowSkillBehaviour.cs # 구현체: 화살 발사 스킬
│
├── Controller/            # 입력 처리 (전략 패턴)
│   ├── PlayerController.cs    # Input System 연동, 사용자 입력
│   └── AiController.cs        # AI 행동 결정, 랜덤 로직
│
├── GameObjectPool/        # 성능 최적화
│   ├── GameObjectPool.cs      # Rent/Return 풀 매니저
│   └── AutoReturnPool.cs      # 자동 반납 컴포넌트
│
├── UI/                    # 뷰 레이어 (이벤트 구독)
│   ├── GameUI.cs              # 게임 상태별 UI 전환
│   ├── UIPlayerStatus.cs      # HP/Shield/Power 게이지
│   ├── UISkillButton.cs       # 스킬 버튼, 쿨타임 표시
│   ├── UIGageBar.cs           # 게이지 바 공통 컴포넌트
│   ├── UIMoveController.cs    # 모바일 가상 조이스틱
│   └── UIAnchorProgress.cs    # 앵커 기반 진행률 표시
│
├── Utils/                 # 순수 유틸리티 (의존성 없음)
│   ├── FBezier.cs             # 3차 베지어 곡선 계산
│   ├── AngleUtils.cs          # 각도 변환 헬퍼
│   ├── TRandom.cs             # 랜덤 유틸리티, Shuffle
│   ├── VectorExtension.cs     # Vector2/3 확장 메서드
│   └── UnityUtils.cs          # Unity 공통 헬퍼
│
└── Components/            # 독립 MonoBehaviour
    ├── GameStatusEvent.cs         # 게임 상태 이벤트 리스너
    ├── LookAtTarget2D.cs          # 2D 타겟 바라보기
    ├── AreaDamage.cs              # 범위 데미지 처리
    ├── RandomPositionOnEnable.cs  # 활성화 시 랜덤 위치
    ├── ReloadAnyKey.cs            # 아무 키 재시작
    ├── UITextDelegate.cs          # 텍스트 델리게이트
    └── *StateMachineBehaviour.cs  # 애니메이터 상태 처리
```

### 클래스 상속/구조도
```
[MonoBehaviour]
    │
    ├── ObjectBehaviour (HP/Shield 관리)
    │       ├── CharacterBehaviour (이동/스킬)
    │       └── ProjectileBehaviour (비행/충돌)
    │
    ├── BaseSkillBehaviour (Abstract)
    │       └── ArrowSkillBehaviour (화살 스킬)
    │
    └── [독립 컴포넌트들]
            ├── PlayerController
            ├── AiController
            ├── GameObjectPool
            └── UI 컴포넌트들
```

### 의존성 다이어그램 (누가 누구를 아는가)
```
┌─────────────────────────────────────────────────────────────┐
│                      Entry Point                            │
│  Startup → GameLoader → GameManager (싱글톤)                │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   Controller    │  │   Character     │  │       UI        │
│ ─────────────── │  │ ─────────────── │  │ ─────────────── │
│ PlayerController│→│CharacterBehaviour│←│ UIPlayerStatus  │
│ AiController    │  │                 │  │ UISkillButton   │
│                 │  │ (InputAxis 설정)│  │ (이벤트 구독)   │
└─────────────────┘  └───────┬─────────┘  └─────────────────┘
                             │
                    ┌────────┴────────┐
                    ▼                 ▼
            ┌─────────────┐    ┌─────────────┐
            │   Skill     │    │   Pool      │
            │ ─────────── │    │ ─────────── │
            │BaseSkillBhv │→→→│GameObjectPool│
            │ArrowSkillBhv│    │  Rent/Return│
            └──────┬──────┘    └─────────────┘
                   │                  ▲
                   ▼                  │
            ┌─────────────────────────┴─┐
            │      Projectile           │
            │ ───────────────────────── │
            │ ProjectileBehaviour       │
            │ (베지어 비행 → 풀 반납)   │
            └───────────────────────────┘
```

### 핵심 원칙
| 원칙 | 설명 | 예시 |
|------|------|------|
| **책임 기반 분류** | 파일 타입이 아닌 역할로 폴더 구분 | Behaviours/, Skills/, Controller/ |
| **단방향 의존성** | UI → Game (O), Game → UI (X) | UI는 이벤트 구독만 |
| **추상화 계층** | Base 클래스로 공통 로직 분리 | ObjectBehaviour, BaseSkillBehaviour |
| **독립 유틸리티** | Utils/는 게임 로직 의존성 없음 | FBezier, TRandom 어디서든 재사용 |

---

## 7) 마지막 "한 줄 무기" 5개

```
✅ "4일 만에 플레이 가능한 게임을 완성했고, 실무형 구조로 정리했습니다."
✅ "상태머신+이벤트로 UI/로직 결합도를 낮췄습니다."
✅ "스킬은 템플릿 구조라 추가 속도가 빠릅니다."
✅ "투사체는 베지어+유도 전환으로 차별점을 넣었습니다."
✅ "풀링+UniTask 자동 취소로 성능/안정성을 챙겼습니다."
```

---

# 📚 상세 문서

## 1) 목표와 제약

### 과제 요구사항
| 구분 | 항목 |
|------|------|
| **필수** | 1v1 실시간 전투, 캐릭터 이동, 스킬 시스템, 기본 AI |
| **선택** | 네트워크 멀티플레이, 데이터 저장, 고급 AI |

### 내가 잡은 완성도 기준
- 시작부터 끝까지 플레이 가능한 게임 루프 (승리/패배 조건)
- 쿨타임 관리되는 5개 이상의 스킬
- 크로스 플랫폼 입력 지원 (키보드/터치/게임패드)
- 모바일 60fps 유지 (오브젝트 풀링 적용)

### 시간 제약(4일/32시간)에서의 원칙
1. **핵심 먼저**: 기능 수량보다 게임플레이 느낌에 집중
2. **재사용 가능한 시스템**: 확장 가능한 스킬/투사체 시스템 설계

---

## 2) 결과물 한눈에 보기

### 핵심 플레이 플로우 (5단계)
```
1. Loading (0.5초) - 데이터 동기화 대기
2. Ready (3초) - 카운트다운 애니메이션
3. Battle (90초) - 메인 전투
4. LimitOver - 시간 초과 시 HP 드레인 (서든데스)
5. Finish - 승자 결정, 재시작 옵션
```

### 구현 완료 / 의도적 제외 목록

| 구현 완료 | 의도적으로 제외 |
|-----------|----------------|
| 게임 상태 머신 | 네트워크 멀티플레이 |
| 캐릭터 이동 (Rigidbody2D) | 데이터 저장/불러오기 |
| 5개 스킬 슬롯 + 기본 공격 | 복잡한 AI (예측/회피) |
| 베지어 곡선 투사체 | 다중 게임 모드 |
| 유도 화살 옵션 | 캐릭터 선택 |
| 오브젝트 풀링 시스템 | 가챠/성장 시스템 |
| 이벤트 기반 UI 바인딩 | 튜토리얼 |
| 크로스 플랫폼 입력 | 다국어 지원 |
| AI 컨트롤러 (단순 랜덤) | |
| HP/Shield/Power 게이지 | |

---

## 3) 핵심 기술 결정 상세

### 3.1 게임 흐름을 위한 상태 머신

| 항목 | 내용 |
|------|------|
| **결론** | Enum 기반 상태 머신 + 이벤트 브로드캐스트 |
| **이유** | 게임 단계 명확히 분리, 새 상태 추가 용이 |
| **대안** | Animator FSM (과도함), Coroutine 체인 (디버깅 어려움) |
| **트레이드오프** | 단순하지만 계층적 상태 없음; 1v1 규모에서는 충분 |
| **파일** | `GameManager.cs:10-58` |

```csharp
public enum EGameStatus { None, Loading, Ready, Start, Battle, Battle_LimitOver, Finish, End }

public EGameStatus Status {
    get => m_Status;
    private set {
        if (m_Status == value) return;
        m_Status = value;
        OnChangedStatus?.Invoke(this, m_Status);  // 이벤트 발행
    }
}
```

### 3.2 베지어 곡선 투사체 시스템

| 항목 | 내용 |
|------|------|
| **결론** | 화살 궤적을 위한 커스텀 3차 베지어 구현 |
| **이유** | 자연스러운 곡선 비행, 곡률 조절 가능, 여러 스킬에 재사용 |
| **대안** | DOTween Path (제어력 부족), 물리 궤적 (예측 불가) |
| **트레이드오프** | 코드 복잡도 증가하지만 타이밍과 경로 완벽 제어 |
| **파일** | `ProjectileBehaviour.cs:200-290`, `FBezier.cs` |

```csharp
FBezier bezier = new FBezier(startPos, targetPos, startAngle, targetAngle, power);
float ratio = Mathf.Clamp01(move / bezier.Distance());
Vector2 position = bezier.Evaluate(ratio);  // 0~1 진행도로 위치 계산
```

### 3.3 성능을 위한 오브젝트 풀링

| 항목 | 내용 |
|------|------|
| **결론** | Rent/Return 패턴의 싱글톤 풀 매니저 |
| **이유** | 빈번한 화살/이펙트 생성으로 인한 GC 스파이크 제거 |
| **대안** | Unity 내장 풀 (2021+), 서드파티 (의존성 추가) |
| **트레이드오프** | 수동 반납 필요; 반납 누락 = 메모리 누수 |
| **파일** | `GameObjectPool.cs` |

```csharp
// 풀에서 빌리기
GameObject arrow = GameObjectPool.main.Rent(prefab, position, rotation);

// 풀에 반납하기 (확장 메서드)
arrow.ReturnPool();

// 정리 콜백
public interface IPoolable { void OnReleased(); }
```

---

## 4) 아키텍처 / 구조

### 폴더 구분 원칙 (Q&A용 한 줄 요약)
```
"파일 타입(cs, anim, prefab)이 아닌 책임(Behaviours, Skills, UI)으로 분류했습니다."
```

### 주요 클래스 책임 분리

| 클래스 | 단일 책임 |
|--------|----------|
| `GameManager` | 게임 상태 전환, 승패 판정 |
| `ObjectBehaviour` | HP/Shield 관리, 피격 처리 |
| `CharacterBehaviour` | 이동, 스킬 실행, 애니메이션 |
| `ProjectileBehaviour` | 비행 경로, 충돌, 풀링 라이프사이클 |
| `BaseSkillBehaviour` | 쿨타임 관리, 스킬 상태 |
| `PlayerController` | 입력 읽기, InputAxis 설정 |
| `AiController` | 행동 결정, InputAxis 설정 |

### 의존성 방향 ("누가 누구를 모르나")

```
UI 레이어      →  구독       →  Game 레이어
                                    ↓
Controller     →  쓰기       →  Character.InputAxis
                                    ↓
Character      →  사용       →  Skill 시스템
                                    ↓
Skill          →  생성       →  Projectile (Pool 경유)
                                    ↓
Projectile     →  알림       →  ObjectBehaviour.OnHit()
```

**핵심**: UI는 Game을 알지만, Game은 UI를 모름 (이벤트 기반 분리)

---

## 5) 데이터 / 흐름

### 이벤트 흐름 (입력 → 로직 → UI/이펙트)

```
[입력 레이어]
PlayerController.Update()
    → InputAction 읽기
    → Character.InputAxis 설정

[로직 레이어]
CharacterBehaviour.FixedUpdate()
    → Rigidbody2D.MovePosition()으로 이동
    → Animator 파라미터 업데이트

CharacterBehaviour.StartSkill()
    → Skill.OnStartSkill() → OnSkillPrepare() → OnSkillActivate()
    → Pool에서 Projectile 생성

ProjectileBehaviour.ShootAsync()
    → 매 프레임 Bezier.Evaluate()
    → OnCollision2D → ObjectBehaviour.OnHit()

[UI 레이어]
ObjectBehaviour.OnChangedHp += UIPlayerStatus.UpdateGauge()
BaseSkillBehaviour.OnChangedStatus += UISkillButton.UpdateCooldown()
GameManager.OnChangedStatus += GameUI.ShowPhaseUI()
```

### 상태 흐름 다이어그램

```
[게임 상태]
Loading → Ready → Start → Battle ─┬─→ Finish → End
                                   │
                        (타임아웃) └─→ Battle_LimitOver → Finish

[캐릭터 상태]
Idle ←→ Walk ←→ Attack/Skill
         ↓
       Ground (물리 체크)

[스킬 상태]
Ready → (사용) → Cooldown → (타이머) → Ready
                    ↓
                  Lock (특수 조건)
```

---

## 6) 품질 / 성능 / 안정성 포인트

### 성능 병목과 처리 방식

| 병목 | 해결책 | 결과 |
|------|--------|------|
| 화살/이펙트 생성 | 오브젝트 풀링 (`GameObjectPool`) | 게임플레이 중 GC 0 |
| Animator 문자열 비교 | 해시 캐싱 (`Animator.StringToHash`) | 프레임당 할당 없음 |
| Coroutine 오버헤드 | UniTask + `destroyCancellationToken` | 자동 정리, 성능 향상 |

### 엣지케이스 처리

| 케이스 | 처리 방법 |
|--------|----------|
| 투사체가 타겟 빗나감 | `m_AutoDestroySec` (5초) 후 자동 삭제 |
| 파괴된 오브젝트의 비동기 태스크 | `destroyCancellationToken` 자동 취소 |
| 잘못된 오브젝트 풀 반납 | 에디터에서 경고 로그 |
| 스킬 중복 발동 | `m_CurrentSkill != null` 체크 |
| 같은 프레임에 양쪽 다 사망 | 먼저 감지된 쪽 승리 (인덱스 순서) |

### 방어 코드 예시
```csharp
// 선택적 컴포넌트 null 조건부
m_Shot?.Play();

// 오래된 실행 방지를 위한 비동기 ID 검증
if (id != m_AsyncId) return;

// 상태 변경 가드
if (m_Status == value) return;
```

---

## 7) 테스트 / 검증

### 수동 테스트 시나리오 (체크리스트)

| # | 시나리오 | 기대 결과 | 상태 |
|---|----------|----------|------|
| 1 | 게임 시작, Ready 카운트다운 대기 | 3-2-1 표시됨 | PASS |
| 2 | A/D 키로 좌우 이동 | 캐릭터가 부드럽게 이동 | PASS |
| 3 | 5개 스킬 순차 사용 | 각 스킬이 애니메이션과 함께 발동 | PASS |
| 4 | 스킬 쿨타임 표시 | UI에 남은 시간 표시 | PASS |
| 5 | 화살이 적에게 명중 | 데미지 적용, 화살이 몸에 박힘 | PASS |
| 6 | 적 HP를 0으로 | 승리 화면 표시 | PASS |
| 7 | 90초 타임아웃 | Battle_LimitOver 단계 시작 | PASS |
| 8 | 모바일 터치 조작 | 가상 조이스틱 작동 | PASS |
| 9 | Xbox 컨트롤러 입력 | 모든 버튼 정상 매핑 | PASS |
| 10 | 스킬 연타 | 중복 발동 없음 | PASS |

### 재현 가능한 버그 (알려진 이슈)

| 버그 | `GameManager.cs:161` - `idx == null` 비교 |
|------|------------------------------------------|
| **증상** | 컴파일러 경고, 로직이 항상 false |
| **원인** | `int` 타입은 null이 될 수 없음, `idx == -1`이어야 함 |
| **영향** | 낮음 - 캐릭터 등록은 여전히 작동 |
| **수정** | `if (idx < 0)`으로 변경 |

---

## 8) 한계와 다음 개선 로드맵

### 현재 기술 부채 목록

| 항목 | 우선순위 | 소요 시간 |
|------|----------|----------|
| `idx == null` 버그 수정 | 높음 | 5분 |
| AI 예측 로직 | 중간 | 2시간 |
| 유닛 테스트 커버리지 | 중간 | 4시간 |
| 데이터 외부화 (JSON/SO) | 낮음 | 2시간 |
| 네트워크 멀티플레이 | 낮음 | 2주 이상 |

### 개선 로드맵

| 기간 | 작업 |
|------|------|
| **1일** | 알려진 버그 수정, 스킬 2개 추가, AI 개선 (회피 로직) |
| **1주** | 밸런싱용 ScriptableObject, 리플레이 시스템, 사운드 폴리싱 |
| **1달** | 온라인 PvP용 Photon 연동, 캐릭터 선택, 랭킹 |

### "여기까지가 현재 완성도"
```
구현됨: 핵심 게임플레이 루프, 확장 가능한 스킬 시스템, 기본 AI
미구현: 네트워크, 저장, 고급 AI, 다중 캐릭터
이유: 4일 제약, 기능보다 플레이 가능한 경험에 우선순위
```

---

# 🎤 발표 스크립트

## 30초 버전

> "**4일(32시간)** 만에 Archer of God 클론을 만들었습니다.
> 핵심 결정은 물리 시뮬레이션 대신 **베지어 곡선 시스템**을 사용해 자연스러운 화살 비행을 구현한 것입니다.
> 결과: 5개 스킬, 크로스 플랫폼 입력, 오브젝트 풀링으로 **60fps 안정적**인 **플레이 가능한 1v1 전투**."

## 3분 버전

**오프닝 (30초)**
> "Archer of God 클론, 4일, 33개 스크립트, 4천 라인. 게임플레이 느낌에 집중했습니다."

**Top 3 결정 (2분)**

1. **상태 머신** (30초)
   > "enum 상태 + 이벤트로 게임 흐름 관리. UI는 구독만 하고 폴링 안 함. 새 단계 추가 쉬움."

2. **베지어 투사체** (30초)
   > "화살 경로에 커스텀 3차 베지어. 물리보다 제어력 좋고, 유도 화살도 지원."

3. **오브젝트 풀링** (30초)
   > "Rent/Return 패턴으로 GC 스파이크 제거. IPoolable 인터페이스로 정리 콜백."

**클로징 (30초)**
> "트레이드오프: 단순한 AI, 네트워크 없음. 하지만 확장 가능한 기반 - 새 스킬 10분 내 추가 가능."

## 10분 딥다이브

| 시간 | 주제 | 핵심 포인트 |
|------|------|------------|
| 0-1분 | 데모 플레이 | 게임플레이, 조작법 보여주기 |
| 1-2분 | 개요 | 4일, 33 스크립트, 폴더 구조 |
| 2-4분 | 아키텍처 | 상태 머신, 이벤트 시스템, 클래스 계층 |
| 4-6분 | 베지어 시스템 | 수학, 코드, 유도 화살 기능 |
| 6-7분 | 풀링 | Rent/Return, IPoolable, 성능 개선 |
| 7-8분 | 스킬 시스템 | 기본 클래스, 템플릿 메서드, 확장성 |
| 8-9분 | 한계점 | 알려진 버그, 미구현 기능 |
| 9-10분 | 로드맵 | 1일 / 1주 / 1달 개선 계획 |

---

# ❓ 예상 Q&A 스크립트

## Q1: "왜 상태 머신을 선택했나요?"
> **결론**: 게임 흐름을 명확히 분리하고 싶었습니다.
> **이유**: 복잡도가 늘어도 각 상태가 독립적으로 관리되어 디버깅이 쉽습니다.
> **대안**: Animator FSM은 게임 로직에 과도하고, Coroutine 체인은 흐름 추적이 어렵습니다.
> **다시 한다면**: 계층적 상태(HFSM)를 고려하겠지만, 1v1 규모에서는 현재 구조로 충분합니다.

## Q2: "베지어 곡선을 직접 구현한 이유는?"
> **결론**: 제어력과 재사용성 때문입니다.
> **이유**: DOTween Path는 런타임 수정이 어렵고, 물리 기반은 예측 불가능합니다.
> **구현**: 시작/끝 위치와 각도로 곡선 생성, `Evaluate(t)`로 0~1 진행도에 따른 위치 계산.
> **효과**: 유도 화살 전환도 자연스럽게 구현할 수 있었습니다.

## Q3: "오브젝트 풀링 없이는 안 되나요?"
> **결론**: 모바일에서는 필수입니다.
> **이유**: 화살이 초당 여러 개 생성/삭제되면 GC 스파이크로 프레임 드랍이 발생합니다.
> **트레이드오프**: 수동 반납이 필요해서 실수 가능성이 있지만, 에디터 경고로 방어했습니다.

## Q4: "UniTask를 선택한 이유는?"
> **결론**: Coroutine 대비 성능과 안전성이 좋습니다.
> **이유**: `destroyCancellationToken`으로 오브젝트 파괴 시 자동 취소되어 메모리 누수를 방지합니다.
> **구현**: async/await 문법으로 가독성도 좋아집니다.

## Q5: "AI가 너무 단순한데요?"
> **결론**: 맞습니다. 시간 제약으로 랜덤 행동만 구현했습니다.
> **개선 방향**: 화살 궤적 예측, 거리 기반 공격/회피 결정, 스킬 우선순위 로직.
> **다시 한다면**: Behavior Tree나 Utility AI를 적용하겠습니다.

## Q6: "가장 어려웠던 부분은?"
> **결론**: 애니메이션 이벤트와 스킬 타이밍 동기화입니다.
> **문제**: "쏘는 순간"이 애니메이션과 안 맞으면 체감이 나빠집니다.
> **해결**: `Prepare → Shot → End` 이벤트 체인으로 정확한 타이밍 제어.

## Q7: "4일 안에 어떻게 완성했나요?"
> **결론**: 우선순위를 명확히 정했습니다.
> **방법**: 네트워크, 복잡한 AI, 데이터 저장은 과감히 제외.
> **원칙**: "플레이 가능한 경험" > "기능 수량"

## Q8: "다시 한다면 뭘 바꾸겠나요?"
> **결론**: 데이터 외부화와 테스트 코드입니다.
> **이유**: 하드코딩된 밸런싱 값들이 수정하기 번거롭고, 수동 테스트만으로는 리그레션 체크가 어렵습니다.

## Q9: "프로젝트 구조를 어떻게 설계했나요?"
> **결론**: 파일 타입이 아닌 **책임** 기반으로 폴더를 구분했습니다.
> **구조**:
> - `Behaviours/` - 게임 오브젝트 (Character, Projectile)
> - `Skills/` - 스킬 시스템 (Base + 구현체)
> - `Controller/` - 입력 처리 (Player, AI)
> - `UI/` - 뷰 레이어 (이벤트 구독만)
> - `Utils/` - 순수 유틸리티 (의존성 없음)
> **원칙**: 단방향 의존성 (UI → Game O, Game → UI X), Base 클래스로 공통 로직 분리
> **효과**: 새 스킬/UI 추가 시 해당 폴더만 수정, 사이드 이펙트 최소화

## Q10: "왜 ObjectBehaviour를 Base로 뒀나요?"
> **결론**: HP/Shield 관리와 피격 처리가 캐릭터/투사체 모두에게 필요해서입니다.
> **구현**: `ObjectBehaviour` → `CharacterBehaviour`, `ProjectileBehaviour`
> **효과**:
> - 데미지 계산, 사망 판정 로직 중복 제거
> - 새 오브젝트 타입 추가 시 기본 기능 자동 상속
> - 이벤트(`OnChangedHp`, `OnDead`) 통일로 UI 바인딩 일관성

---

# 📎 빠른 참조

## 핵심 파일 (오픈 순서)

```
1. GameManager.cs        - 상태 머신, 게임 흐름
2. CharacterBehaviour.cs - 이동, 스킬 실행
3. BaseSkillBehaviour.cs - 스킬 템플릿
4. ProjectileBehaviour.cs - 베지어 비행
5. GameObjectPool.cs     - 성능
```

## 보여주면 안 되는 파일

```
❌ UnityUtils.cs - 주석 처리된 버그 코드
❌ AreaDamage.cs - 3D Physics 사용 (2D 게임인데)
❌ TODO 주석들 - 미완성 인상
```

---

*최종 업데이트: 2025-12-17 09:45*
