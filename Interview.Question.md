
Q.1. 이번 과제에서 최우선 목표는 무엇이었나요?
짧은답: 단기간에 ‘한 판이 완주되는’ 플레이 경험을 만드는 게 목표였고, 그래서 전투 흐름과 피드백을 먼저 잡았습니다.
긴답: 최우선 목표는 단기간에 ‘한 판이 완주되는’ 게임 경험을 만드는 거였습니다. 그래서 디테일한 기능을 다 넣기보다, 시작부터 전투, 승패까지 흐름이 끊기지 않게 만드는 걸 먼저 잡았습니다. 그 위에 타격감과 피드백을 얹는 순서로 접근했습니다.
키워드: 시간제약 → 완주루프 → 검증/개선
긴답: 그건 ‘한 판이 완주되는 플레이 경험’입니다. 시간 제약에서 결과를 빨리 검증해야 했기 때문입니다.

Q.2. 실제 개발 순서를 어떻게 잡았고, 그 이유는 무엇인가요?
짧은답: UI로 게임 흐름을 먼저 파악한 뒤 입력·조작을 안정화하고, 그 다음 전투 핵심(투사체/스킬/AI)을 확장했습니다.
긴답: 실제 순서는 UI부터 시작했습니다. UI를 먼저 배치하면서 게임의 기능과 흐름을 파악해야, 이후 구현 우선순위가 흔들리지 않기 때문입니다. 그 다음 입력/조작을 안정화하고, 캐릭터 움직임→투사체→스킬→AI→이펙트/사운드 순으로 확장했습니다.
키워드: 흐름파악 → 조작안정 → 코어확장
긴답: 그건 ‘UI로 흐름 파악 → 입력 안정화 → 전투 코어 확장’입니다. 우선순위가 흔들리지 않게 하려는 선택이었습니다.

Q.3. “완성도”를 어떤 기준으로 정의했나요?
짧은답: 시작→전투→승패까지 끊김 없이 진행되고, 주요 피드백(HP/피격/스킬)이 자연스럽게 보이면 완성으로 봤습니다.
긴답: 완성도는 ‘플레이어가 한 판을 자연스럽게 끝낼 수 있느냐’로 정의했습니다. 시작 연출, 조작, 전투, 피격/HP 변화, 승패까지 흐름이 끊기지 않고 납득 가능한 피드백이 나오면 일단 완성으로 봤습니다. 그 다음이 폴리시라고 생각합니다.
키워드: 끊김없음 → 체감피드백 → 완주
긴답: 그건 ‘끊김 없이 한 판이 자연스럽게 끝나는 상태’입니다. 유저 체감 기준이 가장 정확하기 때문입니다.

Q.4. 시간 제한이 있을 때, 무엇을 버리고 무엇을 살렸나요?
짧은답: 디테일한 사운드 타이밍·리팩토링은 줄이고, 전투 체감과 코어 루프를 살리는 쪽에 시간을 썼습니다.
긴답: 시간 제한에서는 리팩토링의 완벽함이나 일부 디테일 연출은 과감히 줄였습니다. 대신 유저가 바로 체감하는 조작감, 피격 피드백, 전투 흐름 같은 코어를 살리는 데 집중했습니다. 결과적으로 ‘게임처럼 보이는 상태’를 빨리 만드는 쪽을 선택했습니다.
키워드: 시간부족 → 체감우선 → 마감선확정
긴답: 그건 ‘디테일·리팩토링은 줄이고, 전투 체감은 살린다’입니다. 체감이 곧 결과물이기 때문입니다.

Q.5. 원작과 다르게 “의도적으로” 바꾼 부분이 있나요? 왜 바꿨나요?
짧은답: 시간 내 검증을 위해 디테일 연출은 단순화하고, 게임의 ‘핵심 체감’이 유지되도록 우선순위를 재배치했습니다.
긴답: 원작을 1:1로 복제하기보다, 과제 시간 안에서 핵심 경험이 유지되도록 우선순위를 조정했습니다. 예를 들어 디테일한 사운드 타이밍이나 일부 연출은 단순화하고, 전투 흐름과 피드백이 먼저 성립되게 했습니다. 제한된 시간에서 ‘검증 가능한 재미’를 남기는 선택이었습니다.
키워드: 제약 → 코어우선 → 재미검증
긴답: 그건 ‘디테일 복제보다 코어를 먼저 성립’시킨 겁니다. 검증 가능한 재미를 남기려는 판단이었습니다.

Q.6. 구현 난이도 대비 효과가 큰 기능은 뭐였나요?
짧은답: 투사체 궤적과 피격 피드백(이펙트/데미지 표시)이 가장 체감이 커서 ROI가 높았습니다.
긴답: 효과가 가장 컸던 건 투사체 궤적과 피격 피드백 쪽입니다. 눈에 바로 보이고, 플레이 체감이 즉시 바뀌어서 ‘게임 같아지는’ 속도가 빠릅니다. 그래서 이펙트/데미지 표기 같은 피드백도 같이 묶어서 먼저 만들었습니다.
키워드: 즉시가시성 → 손맛강화 → 만족도상승
긴답: 그건 ‘투사체 궤적 + 피격 피드백’입니다. 보는 순간 체감이 바뀌기 때문입니다.

Q.7. 반대로, 시간을 많이 썼는데 효과가 적었던 부분은 뭐였나요?
짧은답: 동적 풀링 구조를 더 다듬을수록 비용이 커져서, 과제 범위에선 마감선에서 멈췄습니다.
긴답: 동적 풀링을 더 일반화하는 쪽은 시간을 쓰면 확실히 좋아지지만, 과제 범위에서는 체감 대비 효율이 낮아질 수 있었습니다. 그래서 완벽한 범용 구조까지 다듬기보다, 실제 사용 구간에서 안정적으로 동작하는 수준에서 마감선을 정했습니다.
키워드: 범용화욕심 → 비용증가 → 체감낮음
긴답: 그건 ‘풀링을 범용화하는 정리 작업’입니다. 과제 범위에선 체감 대비 비용이 커지기 때문입니다.

Q.8. 과제에서 가장 잘했다고 생각하는 선택 1가지는?
짧은답: 상태머신과 스킬 파이프라인(Prepare/Activate)로 흐름을 고정해, 기능 추가가 빠르게 되게 만든 점입니다.
긴답: 가장 잘한 선택은 게임 진행을 상태머신으로 고정하고, 캐릭터/스킬을 공통 흐름으로 묶은 겁니다. 덕분에 기능을 추가하거나 디버깅할 때 ‘지금 게임이 어느 단계인지’가 명확했고, 애니 이벤트 기반으로 스킬 타이밍도 안정적으로 맞출 수 있었습니다.
키워드: 흐름고정 → 디버깅용이 → 확장가속
긴답: 그건 ‘상태머신으로 흐름을 고정한 것’입니다. 확장과 디버깅 속도가 빨라졌기 때문입니다.

Q.9. 가장 아쉬운 선택 1가지는?
짧은답: 마지막 디테일(특히 사운드·연출 타이밍)을 충분히 못 다듬은 게 아쉽습니다.
긴답: 아쉬운 점은 마감 직전에 사운드 타이밍 같은 폴리시를 충분히 못한 부분입니다. 기능은 완주되게 만들었지만, 마지막 손맛을 더 끌어올리는 시간이 부족했습니다. 다음에는 코어 기능 고정을 더 빨리 해서 디테일 시간을 확보하려고 합니다.
키워드: 마감압박 → 폴리시부족 → 손맛아쉬움
긴답: 그건 ‘사운드/연출 타이밍 폴리시를 더 못한 것’입니다. 마지막 손맛 시간이 부족했기 때문입니다.

Q.10. 다시 한다면 개발 순서를 어떻게 바꾸고 싶은가요?
짧은답: UI는 최소로 빠르게 깔고, 전투 핵심 프로토타입을 더 일찍 돌려 조정 시간을 더 확보하겠습니다.
긴답: 다시 한다면 UI 파악은 하되 더 얇게 가져가고, 전투 코어 프로토타입을 더 빨리 돌릴 것 같습니다. 즉 UI 최소→입력 안정화→투사체/피격/스킬 핵심을 먼저 완성하고, 남는 시간에 연출과 사운드를 붙이겠습니다. 폴리시에 쓸 시간을 의도적으로 확보하는 전략입니다.
키워드: UI최소 → 코어선행 → 폴리시확보
긴답: 그건 ‘UI는 얇게, 전투 코어를 더 빨리’입니다. 폴리시 시간을 확보하려는 전략입니다.

Q.11. 이 게임의 핵심 재미(코어 루프)는 뭐라고 정의했나요?
짧은답: 이동·회피·스킬로 거리/타이밍을 이기고, 피격/게이지 피드백으로 다음 선택을 만드는 루프라고 봤습니다.
긴답: 이 게임의 코어 루프는 거리와 타이밍을 잡고, 스킬과 투사체를 교환하면서 유리한 상황을 만드는 전투라고 봤습니다. 그래서 이동/회피/스킬 타이밍에 대한 피드백이 중요했고, 그게 곧 재미로 연결된다고 판단했습니다.
키워드: 거리/타이밍 → 선택 → 보상피드백
긴답: 그건 ‘거리·타이밍을 잡고 스킬을 교환하는 전투 루프’입니다. 선택과 보상이 반복되기 때문입니다.

Q.12. 타격감을 구성하는 요소를 어떤 것들로 나눴나요?
짧은답: 판정 타이밍, 이펙트/사운드, 데미지 숫자, 피격 애니메이션이 합쳐져 타격감이 만들어진다고 봤습니다.
긴답: 타격감은 단일 요소가 아니라 판정 타이밍, 피격 애니메이션, 이펙트, 데미지 숫자, 사운드가 합쳐진 결과라고 봤습니다. 저는 우선 ‘맞았다는 느낌’이 드는 시각 피드백을 먼저 만들고, 그 다음 사운드로 강화하는 순서를 탔습니다.
키워드: 타이밍 → 시각확신 → 사운드강화
긴답: 그건 세 가지가 있습니다. 첫째 판정 타이밍, 둘째 피격 시각 피드백, 셋째 사운드 강화입니다.

Q.13. 이펙트/사운드/카메라/히트스톱 중 우선순위를 어떻게 뒀나요?
짧은답: 먼저 ‘맞았다고 느끼는’ 피드백(이펙트/애니) → 그 다음 사운드 → 마지막에 추가 연출 순으로 잡았습니다.
긴답: 우선순위는 이펙트/피격 리액션이 1순위, 그 다음 사운드, 그리고 추가 연출입니다. 과제에서는 카메라나 히트스톱까지 확장할 수 있지만, 먼저 핵심 피드백이 있어야 의미가 있다고 봤습니다. 그래서 ‘즉시 체감되는 것’ 위주로 갔습니다.
키워드: 확신 → 강화 → 디테일
긴답: 그건 ‘피격 리액션/이펙트 → 사운드 → 추가 연출’입니다. 맞았다는 확신이 먼저여야 하기 때문입니다.

Q.14. “조작감이 좋다”를 어떤 방식으로 확인했나요?
짧은답: 반복 플레이로 입력 지연/전환 끊김을 체크하고, 이동/공격 타이밍이 자연스러운지로 판단했습니다.
긴답: 조작감은 수치로만 보기보다 반복 플레이로 확인했습니다. 입력이 끊기거나 방향 전환이 어색한 구간이 있는지, 공격/스킬 타이밍이 자연스러운지 위주로 체크했고, 필요한 경우 입력 유지나 딜레이 같은 보정도 넣었습니다.
키워드: 반복 → 끊김탐지 → 즉시수정
긴답: 그건 ‘반복 플레이로 끊김/전환/타이밍을 확인’하는 겁니다. 수치보다 체감이 먼저라서요.

Q.15. 플레이어가 재미를 느끼는 순간을 어디로 봤나요?
짧은답: 회피나 스킬이 ‘의도대로’ 성공했을 때 즉시 피드백이 오는 순간이 재미의 핵심이라 봤습니다.
긴답: 플레이어가 재미를 느끼는 순간은 ‘내 의도대로 회피/공격이 성공하고 즉시 보상 피드백이 오는 순간’이라고 봤습니다. 그래서 성공/실패가 명확히 보이게 피드백을 우선했어요. 이게 게임이 ‘손맛 있다’로 느껴지는 핵심이라고 생각합니다.
키워드: 의도 → 성공 → 즉시보상
긴답: 그건 ‘내 의도대로 성공하고 즉시 보상이 오는 순간’입니다. 즉시 피드백이 재미를 키우기 때문입니다.

Q.16. 원작을 분석할 때 가장 먼저 본 요소는 무엇이었나요?
짧은답: 전투 흐름과 입력 규칙부터 먼저 봤고, 그 다음 연출 디테일을 맞췄습니다.
긴답: 원작 분석은 그래픽보다 먼저 전투 흐름과 입력 규칙을 봤습니다. UI를 따라 만들며 어떤 정보가 전투에 중요한지, 어떤 타이밍에 무엇이 일어나는지를 파악했고, 그 다음에 연출 디테일을 맞췄습니다.
키워드: 룰파악 → 흐름정리 → 우선순위설정
긴답: 그건 ‘룰과 전투 흐름’입니다. 그래픽보다 규칙이 재미를 결정하기 때문입니다.

Q.17. UI를 먼저 구현하며 파악한 핵심 기능/흐름은 무엇이었나요?
짧은답: HP/실드/파워 같은 전투 정보와, 전투 상태 변화가 유저에게 어떻게 전달되는지부터 정리했습니다.
긴답: UI를 먼저 구현하면서 HP/실드/파워 같은 전투 정보 구조와, 시작/전투/종료 흐름을 빨리 파악할 수 있었습니다. 어떤 상태에서 어떤 버튼이 의미를 갖는지도 정리돼서, 이후 기능 우선순위를 잡는 데 도움이 됐습니다.
키워드: 정보구조 → 상태흐름 → 구현우선순위
긴답: 그건 ‘전투 정보 구조와 상태 흐름’입니다. UI가 중요도를 그대로 보여주기 때문입니다.

Q.18. 밸런스는 어떤 기준으로 맞췄나요? (또는 맞추지 못했다면 이유는?)
짧은답: 과제 범위에선 원작 체감과 플레이 반복으로 조정했고, 상용화라면 데이터화해서 튜닝 가능하게 만들겠습니다.
긴답: 과제 범위에서는 정량 밸런싱까지는 어렵고, 원작 체감에 맞게 플레이 반복으로 조정했습니다. 다만 상용화 기준이라면 스킬/피해량/쿨타임 등을 데이터화해서, 수치 조정이 코드 수정 없이 가능하도록 만들겠습니다.
키워드: 원작체감 → 반복튜닝 → 납득감확보
긴답: 그건 ‘원작 체감 기반의 빠른 튜닝’입니다. 과제에선 데이터 밸런싱보다 체감 검증이 빠르기 때문입니다.

Q.19. GameManager를 상태 머신으로 둔 이유는?
짧은답: 게임 흐름을 단계로 고정하면 디버깅이 쉽고, UI/캐릭터가 상태에 맞춰 깔끔히 반응합니다.
긴답: 상태머신은 게임 흐름을 명확히 고정해서 디버깅과 확장을 쉽게 합니다. Ready/Start/Battle/Finish처럼 단계가 있으면 UI나 캐릭터가 상태에 맞춰 반응하기가 깔끔하고, ‘지금 뭐가 정상인지’가 명확해집니다.
키워드: 흐름고정 → 정상정의 → 유지보수
긴답: 그건 ‘흐름을 고정해서 구현을 안정화’하려는 겁니다. 정상 상태가 명확해지기 때문입니다.

Q.20. 상태 변화 이벤트(OnChangedStatus)를 둔 이유는?
짧은답: 상태 변화에 반응하는 객체들을 느슨하게 연결해, 결합도를 낮추려고 이벤트로 분리했습니다.
긴답: 상태 변화 이벤트는 결합도를 낮추기 위한 선택입니다. 매니저가 모든 객체를 직접 제어하기보다, 캐릭터나 UI가 상태 변화에 스스로 반응하게 만들면 구조가 단순해지고 유지보수가 쉬워집니다.
키워드: 결합도↓ → 반응형 → 수정범위↓
긴답: 그건 ‘결합도를 낮추고 각 객체가 반응하게’ 하려는 겁니다. 확장 시 수정 범위가 줄어들기 때문입니다.

Q.21. CharacterBehaviour와 ObjectBehaviour를 분리한 이유는?
짧은답: 공통(HP/실드/피격)은 Object로, 조작/스킬/이동은 Character로 나눠 확장성을 확보했습니다.
긴답: HP/실드/피격 같은 공통 생명체 로직은 ObjectBehaviour로 두고, 조작/스킬/이동은 CharacterBehaviour로 분리했습니다. 이렇게 하면 캐릭터 외의 대상에도 같은 피격 시스템을 재사용할 수 있고, 확장할 때 구조가 덜 꼬입니다.
키워드: 공통분리 → 책임명확 → 재사용확장
긴답: 그건 ‘공통 피격 로직과 조작/스킬을 분리’한 겁니다. 재사용과 확장에 유리하기 때문입니다.

Q.22. “전투 로직”은 어디에 두는 게 맞다고 생각하나요? (현재 구조의 장단점)
짧은답: 피격 처리의 공통은 Object에 두고, 공격자 스탯 반영은 OnAttack 오버라이드로 확장했습니다.
긴답: 방어/피격 처리는 공통이라 Object에 두고, 공격자 스탯 반영은 공격자 쪽에서 오버라이드로 처리하는 방식이 유연합니다. 장점은 공통 규칙이 한 곳에 모이고, 단점은 이벤트 흐름을 이해해야 해서 문서화가 필요하다는 점입니다.
키워드: 공통규칙 → 개별보정 → 책임분리
긴답: 그건 ‘공통 규칙은 Object, 공격자 보정은 Character’가 맞다고 봅니다. 책임이 섞이면 확장이 어려워져서요.

Q.23. 스킬을 BaseSkillBehaviour로 분리한 이유는?
짧은답: 스킬마다 다른 점만 남기고, 시작/소비/발동 흐름은 공통화해서 추가 비용을 줄이려 했습니다.
긴답: 스킬마다 다른 건 ‘발동 조건/효과’이고, 공통은 ‘시작→준비→발사→종료’ 흐름입니다. 그 공통 흐름을 베이스로 묶으면 스킬 추가가 빨라지고, 애니메이션과도 연결하기 쉽습니다.
키워드: 표준흐름 → 추가속도 → 유지비용↓
긴답: 그건 ‘스킬 공통 흐름을 표준화’하려는 겁니다. 스킬이 늘수록 추가 속도가 빨라지기 때문입니다.

Q.24. 스킬의 Prepare/Activate를 나눈 이유는?
짧은답: 애니메이션 타이밍에 맞춰 ‘장전’과 ‘발사’를 분리해야 연출과 판정이 정확히 맞습니다.
긴답: 준비(Prepare)는 장전/조준 같은 연출 단계고, 발사(Activate)는 실제 판정이 나가는 단계입니다. 애니메이션 타이밍과 정확히 맞춰야 타격감이 생기기 때문에, 두 단계를 분리해서 제어했습니다.
키워드: 연출준비 → 판정발사 → 타이밍일치
긴답: 그건 ‘준비 연출과 실제 판정을 분리’한 겁니다. 타이밍 일치가 손맛이라서요.

Q.25. 애니메이션 이벤트 기반으로 스킬을 발동시킨 장점은?
짧은답: 보이는 타이밍과 실제 판정을 일치시켜, 플레이 감각이 흔들리지 않게 합니다.
긴답: 보이는 타이밍과 실제 판정이 일치한다는 게 가장 큽니다. 그냥 시간으로 쏘면 애니메이션과 어긋나서 ‘헛치는 느낌’이 나는데, 애니 이벤트로 맞추면 손맛이 안정적으로 유지됩니다.
키워드: 시각일치 → 납득감 → 손맛안정
긴답: 그건 ‘보이는 순간과 맞는 순간이 같아지는 것’입니다. 체감이 안정되기 때문입니다.

Q.26. 지금 구조에서 스킬이 50개로 늘면 어떤 문제가 생길까요?
짧은답: 코드 중복·세팅 비용이 커지니, 데이터(예: ScriptableObject) 중심으로 전환해야 합니다.
긴답: 지금 방식 그대로 늘리면 스킬별 하드코딩과 세팅 비용이 커질 수 있습니다. 상용화라면 스킬을 데이터 중심(ScriptableObject 등)으로 바꾸고, 공통 로직은 모듈화해서 ‘데이터로 조합’ 가능하게 해야 유지가 됩니다.
키워드: 규모증가 → 비용폭증 → 데이터화필수
긴답: 그건 ‘하드코딩과 세팅 비용 폭증’입니다. 데이터화 없이는 유지가 어려워서요.

Q.27. 확장성을 위해 인터페이스/DI를 넣는다면 어디부터 넣겠나요?
짧은답: Input, Pool, Settings 같은 외부 의존부터 인터페이스로 빼면 테스트/교체가 쉬워집니다.
긴답: 입력, 풀, 설정값, 사운드 같은 외부 의존부터 인터페이스로 빼는 게 효과가 큽니다. 그러면 테스트가 쉬워지고, 플랫폼이나 정책 변경에도 교체가 간단해집니다.
키워드: 외부의존 → 교체용이 → 테스트가능
긴답: 그건 ‘입력/풀/설정/사운드 같은 외부 의존부터’입니다. 교체와 테스트가 쉬워지기 때문입니다.

Q.28. 코드를 다시 정리한다면 어떤 기준으로 폴더/레이어를 나누겠나요?
짧은답: Core(상태/유틸) / Gameplay(캐릭터·스킬·투사체) / UI / FX 로 분리하겠습니다.
긴답: Core(상태/유틸) / Gameplay(캐릭터·스킬·투사체) / UI / FX·Audio / Data로 나누겠습니다. 그리고 런타임 의존 방향을 ‘Core→Gameplay→UI’처럼 단방향으로 유지하면 유지보수가 쉬워집니다.
키워드: 레이어링 → 단방향의존 → 유지보수
긴답: 그건 ‘Core → Gameplay → UI/FX → Data’ 순서로 나누는 겁니다. 의존 방향을 단방향으로 만들기 때문입니다.

Q.29. Input System을 어떻게 래핑했고, 왜 그 방식을 선택했나요?
짧은답: Input System 액션을 받아 Character의 InputAxis/스킬 트리거로 변환해, 게임 로직과 입력을 분리했습니다.
긴답: Input System 액션을 바로 게임 로직에 박기보다, 캐릭터의 InputAxis나 스킬 트리거로 변환해 연결했습니다. 입력 계층과 게임 로직을 분리하면, AI/리플레이/모바일 입력 같은 확장이 쉬워집니다.
키워드: 입력분리 → 인터페이스화 → 확장
긴답: 그건 ‘입력을 축/트리거로 변환해 게임 로직과 분리’한 겁니다. AI/모바일 확장이 쉬워져서요.

Q.30. 입력 지연(move_input_delay)을 둔 이유는?
짧은답: 순간 입력 끊김을 완화해 조작감이 더 안정적으로 느껴지게 하려는 의도였습니다.
긴답: 입력이 순간적으로 0이 되는 구간이 있으면 조작감이 끊겨 보일 수 있어서, 짧은 유지 시간을 둬서 ‘의도한 이동’이 자연스럽게 보이도록 했습니다. 특히 짧은 과제에서 체감 품질을 빠르게 올리는 데 도움이 됩니다.
키워드: 끊김발생 → 흡수보정 → 체감개선
긴답: 그건 ‘순간 입력 끊김을 흡수’하려는 겁니다. 체감 조작감을 부드럽게 만들기 때문입니다.

Q.31. Update와 FixedUpdate 역할을 어떻게 분리했나요?
짧은답: 판단·애니 상태는 Update, 물리 이동은 FixedUpdate로 나눠 예측 가능한 움직임을 만들었습니다.
긴답: Update에서는 상태 판단과 애니메이션 파라미터 갱신을 하고, FixedUpdate에서는 물리 기반 이동만 처리했습니다. 이렇게 분리하면 프레임 변동이 있어도 물리 움직임이 예측 가능해지고, 조작감도 안정됩니다.
키워드: 판단 → 물리 → 안정
긴답: 그건 ‘판단/애니는 Update, 물리 이동은 Fixed’입니다. 프레임 변동에도 안정적이기 때문입니다.

Q.32. 조작감과 물리 안정성을 위해 어떤 트레이드오프를 했나요?
짧은답: 정밀한 물리보다 ‘조작감’이 우선이라, 플레이 체감이 좋은 쪽으로 타협했습니다.
긴답: 물리적으로 완벽한 시뮬레이션보다 ‘손에 붙는 조작감’을 우선했습니다. 예를 들어 이동은 단순하고 예측 가능하게 만들고, 스킬 중엔 조작을 제한하는 식으로 플레이 체감을 안정화했습니다.
키워드: 체감우선 → 단순화 → 안정
긴답: 그건 ‘물리 완벽함보다 손에 붙는 체감’을 우선한 겁니다. 게임은 체감이 결과라서요.

Q.33. 모바일 환경을 고려하면 입력 처리를 어떻게 바꿀 건가요?
짧은답: 가상패드/제스처 입력과 입력 버퍼를 넣고, 프레임 변동에도 체감이 유지되게 보정하겠습니다.
긴답: 모바일이면 가상 조이스틱/버튼 입력을 추가하고, 입력 버퍼나 터치 슬립 보정을 넣겠습니다. 또 프레임이 흔들려도 체감이 유지되도록, 입력 샘플링과 이동 보정 로직을 더 보수적으로 가져갈 겁니다.
키워드: 터치UI → 버퍼링 → 보정
긴답: 그건 세 가지가 있습니다. 첫째 가상 입력 UI, 둘째 입력 버퍼, 셋째 프레임 변동 보정입니다.

Q.34. 화살 궤적을 Bezier로 만든 이유는? 직선/포물선과 비교하면?
짧은답: 원작 느낌에 가까운 곡선 궤적이 전투 재미를 만들고, 직선보다 회피/타이밍 플레이가 살아납니다.
긴답: Bezier는 원작 느낌의 ‘휘어지는 궤적’을 빠르게 만들 수 있고, 회피/타이밍 플레이가 살아납니다. 직선은 단순하지만 재미가 단조로워질 수 있고, 포물선은 물리 기반 튜닝이 더 필요해서 과제 시간엔 Bezier가 효율적이었습니다.
키워드: 재현목표 → 곡선선택 → 재미강화
긴답: 그건 ‘원작 느낌의 곡선 궤적을 빠르게 재현’하기 위함입니다. 타이밍/회피 재미가 살아나서요.

Q.35. 유도 기능은 어떤 로직으로 동작하나요? (언제부터 유도, 속도 증가 방식 등)
짧은답: 일정 거리 이후 타겟 방향으로 보간하며 속도를 가산해, 자연스럽게 추적하도록 했습니다.
긴답: 일정 거리까지는 정해진 궤적으로 가고, 특정 시점 이후엔 타겟 방향으로 보간하면서 속도를 가산해 추적하게 했습니다. 너무 일찍 유도하면 회피 재미가 줄어들 수 있어서, ‘언제부터 유도할지’가 핵심 파라미터라고 봤습니다.
키워드: 구간조건 → 방향보간 → 속도증가
긴답: 그건 세 가지입니다. 첫째 일정 거리까지는 궤적 유지, 둘째 이후 타겟 방향 보간, 셋째 속도 가산입니다.

Q.36. “Owner는 안 맞는다” 처리를 왜 이렇게 했나요?
짧은답: 발사자와의 충돌은 무시해 자기 피격을 막고, 의도치 않은 판정을 줄이려 했습니다.
긴답: 발사자와의 충돌을 무시해서 자기 피격 같은 의도치 않은 판정을 막기 위한 처리입니다. 특히 근접 거리에서 투사체가 생성될 때, 충돌 판정이 먼저 나가버리는 문제를 예방하는 목적도 있습니다.
키워드: 오작동위험 → 예외처리 → 안정
긴답: 그건 ‘자기 피격과 근접 생성 오작동 방지’입니다. 판정 안정성이 먼저라서요.

Q.37. 충돌 처리를 OnTrigger/OnCollision 혼용한 이유는?
짧은답: 환경/프리팹 구성 차이를 흡수하려고 둘 다 지원해 충돌 누락을 줄였습니다.
긴답: 환경/프리팹 설정에 따라 트리거만 쓰거나 콜리전만 쓰면 누락이 생길 수 있어서 둘 다 대응했습니다. 과제 환경에선 안정적으로 ‘맞는 판정’이 나오게 하는 게 더 중요하다고 판단했습니다.
키워드: 환경차이 → 누락위험 → 방어구현
긴답: 그건 ‘환경/프리팹 차이로 생기는 누락을 줄이려는 방어’입니다. 맞아야 할 때 확실히 맞게 하려는 목적입니다.

Q.38. 피어싱(관통) 옵션의 설계 의도와 구현 방식은?
짧은답: 관통은 ‘맞아도 소멸하지 않고 계속 진행’하게 해서, 스킬 성격을 옵션으로 분리했습니다.
긴답: 관통은 맞아도 소멸하지 않고 계속 진행해서, 스킬 성격을 다양화하기 위한 옵션입니다. 그래서 히트 후 파괴/비활성화를 막고, 충돌 처리만 반복되도록 분기했습니다.
키워드: 의도(다양성) → 옵션화 → 처리분기
긴답: 그건 ‘맞아도 소멸하지 않게 해서 스킬 성격을 바꾸는 것’입니다. 다양성을 옵션으로 분리한 겁니다.

Q.39. 데미지 처리(실드→HP)를 이렇게 설계한 이유는?
짧은답: 방어 레이어가 분리되면 피드백이 명확하고, 전투에서 선택(버티기/공격)이 선명해집니다.
긴답: 실드가 먼저 깎이면 전투 피드백이 명확하고, ‘버티는 구간’이 생겨서 플레이 선택지가 분명해집니다. 또 UI에서도 실드/HP 변화를 구분하기 쉬워서 전투 정보 전달이 좋아집니다.
키워드: 명확한정보 → 선택지 → 납득감
긴답: 그건 ‘피드백을 명확히 하고 전투 선택지를 만들기’ 위함입니다. 정보가 선명해지기 때문입니다.

Q.40. 크리티컬 계산 로직에서 개선할 점이 있나요?
짧은답: 확률/배수 계산은 테스트로 검증하고, 수치가 데이터로 조정 가능하게 분리하겠습니다.
긴답: 확률/배수 자체는 단순하지만, 상용화라면 난수/확률 검증과 밸런스 데이터화를 강화하겠습니다. 예를 들어 크리티컬이 체감상 과도하게 터지거나 안 터지는 문제가 생기지 않도록 테스트 기반으로 조정할 겁니다.
키워드: 데이터화 → 검증 → 편차감소
긴답: 그건 ‘데이터화하고 확률 체감을 검증’하는 겁니다. 편차가 체감 품질을 깨기 때문입니다.

Q.41. 전투 숫자(데미지 텍스트/크리티컬 텍스트) 출력은 왜 풀링했나요?
짧은답: 전투 중 다량 생성되므로 풀링으로 GC와 스파이크를 줄이려 했습니다.
긴답: 전투 중 텍스트가 많이 생성되면 GC와 스파이크가 생길 수 있어서 풀링했습니다. 과제에서도 체감 프레임을 지키는 게 중요했고, 작은 비용으로 안정성을 얻을 수 있는 선택이었습니다.
키워드: 반복생성 → GC스파이크 → 프레임안정
긴답: 그건 ‘전투 중 반복 생성으로 생기는 GC 스파이크 방지’입니다. 프레임 안정이 체감에 직결돼서요.

Q.42. 투사체가 경계 넘어가면 Dynamic으로 바꾸는 의도는 무엇인가요?
짧은답: 초반엔 키네마틱으로 궤적을 정확히 제어하고, 특정 시점부터 물리 충돌을 활성화하려는 의도였습니다.
긴답: 초반에는 키네마틱으로 궤적을 정확히 제어하고, 특정 구간 이후엔 물리 충돌을 활성화해 자연스러운 충돌 반응을 얻으려는 의도였습니다. 즉 ‘제어되는 이동’과 ‘물리 판정’을 구간별로 나눠 쓰는 방식입니다.
키워드: 제어이동 → 판정활성 → 양쪽확보
긴답: 그건 ‘초반은 궤적을 제어하고, 이후는 물리 판정을 살리는 것’입니다. 재현과 안정성을 같이 얻기 때문입니다.

Q.43. 투사체가 타겟에 박히는 연출(랜덤 회전/지연)은 왜 넣었나요?
짧은답: 랜덤 회전/지연을 넣어 반복감을 줄이고, ‘박혔다’는 손맛을 강화하려 했습니다.
긴답: 동일한 박힘 연출이 반복되면 티가 나서, 약간의 랜덤 회전과 지연으로 생동감을 주려 했습니다. 그리고 ‘맞고 끝’이 아니라 ‘박혔다’는 느낌을 주면 타격감이 더 좋아집니다.
키워드: 반복감↓ → 변주 → 손맛↑
긴답: 그건 ‘반복감을 줄이고 박힘 손맛을 강화’하려는 겁니다. 미세 변주가 체감을 키우기 때문입니다.

Q.44. 이 프로젝트에서 GC Alloc이 발생할 만한 곳은 어디인가요?
짧은답: LINQ/컬렉션 변환, GetComponents 호출, 반복 생성되는 텍스트/이펙트가 우선 점검 대상입니다.
긴답: LINQ나 컬렉션 변환, GetComponents 계열 호출, 전투 중 반복 생성되는 이펙트/텍스트가 우선 의심 지점입니다. 과제에선 속도 우선으로 쓴 부분이 있어, 상용화라면 프로파일러로 Alloc 지점을 잡고 풀링/캐싱을 강화하겠습니다.
키워드: 변환 → 반복호출 → 생성
긴답: 그건 세 가지가 흔합니다. 첫째 LINQ/변환, 둘째 반복 GetComponents, 셋째 전투 중 생성(텍스트/이펙트)입니다.

Q.45. DOTween 페이드 사용의 장단점은? 대체안은?
짧은답: 구현이 빠르고 깔끔하지만 의존성이 생기니, 필요하면 코루틴/직접 알파 제어로 대체 가능합니다.
긴답: 장점은 구현 속도와 가독성이 좋다는 거고, 단점은 의존성과 런타임 비용을 신경 써야 한다는 점입니다. 필요하면 코루틴이나 직접 알파 값을 업데이트하는 방식으로 대체할 수 있습니다.
키워드: 생산성 → 의존성 → 대체가능
긴답: 그건 ‘빠르게 만들 수 있지만 의존이 생긴다’입니다. 필요하면 코루틴/직접 알파 갱신으로 대체 가능합니다.

Q.46. 오브젝트 풀링에서 가장 흔한 버그와 예방 방법은?
짧은답: 상태 초기화 누락이 가장 흔해서, OnEnable/Clear로 값·컴포넌트 상태를 반드시 리셋합니다.
긴답: 가장 흔한 건 상태 초기화 누락입니다. 그래서 OnEnable/Clear 같은 구간에서 위치/속도/알파/콜라이더/파티클 상태를 강제로 리셋하고, ‘반납 시점’을 일관되게 관리하는 게 중요합니다.
키워드: 재사용 → 초기화 → 일관성
긴답: 그건 ‘상태 초기화 누락’입니다. 반납/재사용 시 Clear를 강제해야 예방됩니다.

Q.47. 비동기(UniTask) 사용 시 취소/중복 실행 문제는 어떻게 막았나요?
짧은답: destroyCancellationToken과 실행 ID 같은 가드로, 오브젝트 종료/재시작 시 중복 동작을 막았습니다.
긴답: 오브젝트가 꺼지거나 재사용될 때 이전 태스크가 계속 돌면 버그가 생깁니다. 그래서 destroyCancellationToken을 쓰고, 실행 ID(가드 값)를 두어 ‘최신 실행만 유효’하게 만들어 중복 실행을 막았습니다.
키워드: 중복위험 → 취소 → 최신유효
긴답: 그건 ‘CancellationToken + 실행 ID 가드’입니다. 재사용 중 이전 작업이 남는 걸 막기 때문입니다.

Q.48. “지금 당장 상용화”라면 가장 먼저 고칠 부분 3가지는?
짧은답: 데이터화(밸런스/스킬), 입력·상태 분리 리팩토링, 테스트/로그 체계를 먼저 강화하겠습니다.
긴답: 첫째 데이터화(스킬/수치/쿨타임), 둘째 입력·상태·전투 로직의 결합도 정리, 셋째 테스트/로그/프로파일링 기반의 품질 관리입니다. 특히 스킬이 늘어날수록 데이터 중심 구조가 필수라고 봅니다.
키워드: 데이터 → 구조 → 품질
긴답: 그건 세 가지입니다. 첫째 데이터화, 둘째 결합도 정리, 셋째 테스트/프로파일링 체계입니다.

Q.49. 테스트(재현/디버깅)는 어떤 방식으로 했나요?
짧은답: 반복 플레이로 재현하고, 로그/기즈모로 시각화해 원인 좁히는 방식으로 디버깅했습니다.
긴답: 반복 플레이로 재현 조건을 좁히고, 로그와 기즈모 같은 시각화로 원인을 줄였습니다. 과제에선 시간이 짧아서 ‘빨리 재현→원인 축소→수정’ 루프를 빠르게 도는 게 핵심이었습니다.
키워드: 재현 → 관찰 → 축소
긴답: 그건 ‘반복 재현 → 로그/시각화 → 원인 축소’입니다. 짧은 시간에 확실히 잡히기 때문입니다.

Q.50. 본인이 생각하는 이 과제 결과물의 강점/약점을 한 문장씩 말해보세요.
짧은답: 강점은 짧은 기간에 플레이 가능한 전투 경험을 만든 점이고, 약점은 리팩토링·연출 디테일을 더 다듬을 시간이 부족했던 점입니다.
긴답: 강점은 짧은 기간에 실제로 플레이 가능한 전투 경험과 코어 흐름을 완성한 점입니다. 약점은 마감 직전에 사운드/연출 타이밍 같은 폴리시를 더 다듬을 시간이 부족했던 점이고, 다음엔 그 시간을 확보하도록 순서를 조정하겠습니다.
키워드: 완주경험(강점) → 폴리시부족(약점) → 개선계획
긴답: 그건 두 가지입니다. 강점은 ‘완주 가능한 전투 경험’, 약점은 ‘폴리시(사운드/타이밍) 시간이 부족’입니다.
